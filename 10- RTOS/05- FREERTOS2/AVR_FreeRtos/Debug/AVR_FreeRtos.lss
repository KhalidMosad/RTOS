
AVR_FreeRtos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002fa4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002fa4  00003038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000573  00800068  00800068  00003040  2**0
                  ALLOC
  3 .stab         00004b24  00000000  00000000  00003040  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002d6c  00000000  00000000  00007b64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 42 0c 	jmp	0x1884	; 0x1884 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ea       	ldi	r30, 0xA4	; 164
      68:	ff e2       	ldi	r31, 0x2F	; 47
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 3d       	cpi	r26, 0xDB	; 219
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <main>
      8a:	0c 94 d0 17 	jmp	0x2fa0	; 0x2fa0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_VidSetPinDirection>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	27 97       	sbiw	r28, 0x07	; 7
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	6a 83       	std	Y+2, r22	; 0x02
      aa:	4b 83       	std	Y+3, r20	; 0x03
      ac:	8b 81       	ldd	r24, Y+3	; 0x03
      ae:	81 30       	cpi	r24, 0x01	; 1
      b0:	09 f0       	breq	.+2      	; 0xb4 <DIO_VidSetPinDirection+0x22>
      b2:	6f c0       	rjmp	.+222    	; 0x192 <DIO_VidSetPinDirection+0x100>
      b4:	89 81       	ldd	r24, Y+1	; 0x01
      b6:	28 2f       	mov	r18, r24
      b8:	30 e0       	ldi	r19, 0x00	; 0
      ba:	3f 83       	std	Y+7, r19	; 0x07
      bc:	2e 83       	std	Y+6, r18	; 0x06
      be:	8e 81       	ldd	r24, Y+6	; 0x06
      c0:	9f 81       	ldd	r25, Y+7	; 0x07
      c2:	81 30       	cpi	r24, 0x01	; 1
      c4:	91 05       	cpc	r25, r1
      c6:	49 f1       	breq	.+82     	; 0x11a <DIO_VidSetPinDirection+0x88>
      c8:	2e 81       	ldd	r18, Y+6	; 0x06
      ca:	3f 81       	ldd	r19, Y+7	; 0x07
      cc:	22 30       	cpi	r18, 0x02	; 2
      ce:	31 05       	cpc	r19, r1
      d0:	2c f4       	brge	.+10     	; 0xdc <DIO_VidSetPinDirection+0x4a>
      d2:	8e 81       	ldd	r24, Y+6	; 0x06
      d4:	9f 81       	ldd	r25, Y+7	; 0x07
      d6:	00 97       	sbiw	r24, 0x00	; 0
      d8:	61 f0       	breq	.+24     	; 0xf2 <DIO_VidSetPinDirection+0x60>
      da:	d2 c0       	rjmp	.+420    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
      dc:	2e 81       	ldd	r18, Y+6	; 0x06
      de:	3f 81       	ldd	r19, Y+7	; 0x07
      e0:	22 30       	cpi	r18, 0x02	; 2
      e2:	31 05       	cpc	r19, r1
      e4:	71 f1       	breq	.+92     	; 0x142 <DIO_VidSetPinDirection+0xb0>
      e6:	8e 81       	ldd	r24, Y+6	; 0x06
      e8:	9f 81       	ldd	r25, Y+7	; 0x07
      ea:	83 30       	cpi	r24, 0x03	; 3
      ec:	91 05       	cpc	r25, r1
      ee:	e9 f1       	breq	.+122    	; 0x16a <DIO_VidSetPinDirection+0xd8>
      f0:	c7 c0       	rjmp	.+398    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
      f2:	aa e3       	ldi	r26, 0x3A	; 58
      f4:	b0 e0       	ldi	r27, 0x00	; 0
      f6:	ea e3       	ldi	r30, 0x3A	; 58
      f8:	f0 e0       	ldi	r31, 0x00	; 0
      fa:	80 81       	ld	r24, Z
      fc:	48 2f       	mov	r20, r24
      fe:	8a 81       	ldd	r24, Y+2	; 0x02
     100:	28 2f       	mov	r18, r24
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	81 e0       	ldi	r24, 0x01	; 1
     106:	90 e0       	ldi	r25, 0x00	; 0
     108:	02 2e       	mov	r0, r18
     10a:	02 c0       	rjmp	.+4      	; 0x110 <DIO_VidSetPinDirection+0x7e>
     10c:	88 0f       	add	r24, r24
     10e:	99 1f       	adc	r25, r25
     110:	0a 94       	dec	r0
     112:	e2 f7       	brpl	.-8      	; 0x10c <DIO_VidSetPinDirection+0x7a>
     114:	84 2b       	or	r24, r20
     116:	8c 93       	st	X, r24
     118:	b3 c0       	rjmp	.+358    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     11a:	a7 e3       	ldi	r26, 0x37	; 55
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e7 e3       	ldi	r30, 0x37	; 55
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	8a 81       	ldd	r24, Y+2	; 0x02
     128:	28 2f       	mov	r18, r24
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	81 e0       	ldi	r24, 0x01	; 1
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	02 2e       	mov	r0, r18
     132:	02 c0       	rjmp	.+4      	; 0x138 <DIO_VidSetPinDirection+0xa6>
     134:	88 0f       	add	r24, r24
     136:	99 1f       	adc	r25, r25
     138:	0a 94       	dec	r0
     13a:	e2 f7       	brpl	.-8      	; 0x134 <DIO_VidSetPinDirection+0xa2>
     13c:	84 2b       	or	r24, r20
     13e:	8c 93       	st	X, r24
     140:	9f c0       	rjmp	.+318    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     142:	a4 e3       	ldi	r26, 0x34	; 52
     144:	b0 e0       	ldi	r27, 0x00	; 0
     146:	e4 e3       	ldi	r30, 0x34	; 52
     148:	f0 e0       	ldi	r31, 0x00	; 0
     14a:	80 81       	ld	r24, Z
     14c:	48 2f       	mov	r20, r24
     14e:	8a 81       	ldd	r24, Y+2	; 0x02
     150:	28 2f       	mov	r18, r24
     152:	30 e0       	ldi	r19, 0x00	; 0
     154:	81 e0       	ldi	r24, 0x01	; 1
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	02 2e       	mov	r0, r18
     15a:	02 c0       	rjmp	.+4      	; 0x160 <DIO_VidSetPinDirection+0xce>
     15c:	88 0f       	add	r24, r24
     15e:	99 1f       	adc	r25, r25
     160:	0a 94       	dec	r0
     162:	e2 f7       	brpl	.-8      	; 0x15c <DIO_VidSetPinDirection+0xca>
     164:	84 2b       	or	r24, r20
     166:	8c 93       	st	X, r24
     168:	8b c0       	rjmp	.+278    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     16a:	a1 e3       	ldi	r26, 0x31	; 49
     16c:	b0 e0       	ldi	r27, 0x00	; 0
     16e:	e1 e3       	ldi	r30, 0x31	; 49
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	80 81       	ld	r24, Z
     174:	48 2f       	mov	r20, r24
     176:	8a 81       	ldd	r24, Y+2	; 0x02
     178:	28 2f       	mov	r18, r24
     17a:	30 e0       	ldi	r19, 0x00	; 0
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	90 e0       	ldi	r25, 0x00	; 0
     180:	02 2e       	mov	r0, r18
     182:	02 c0       	rjmp	.+4      	; 0x188 <DIO_VidSetPinDirection+0xf6>
     184:	88 0f       	add	r24, r24
     186:	99 1f       	adc	r25, r25
     188:	0a 94       	dec	r0
     18a:	e2 f7       	brpl	.-8      	; 0x184 <DIO_VidSetPinDirection+0xf2>
     18c:	84 2b       	or	r24, r20
     18e:	8c 93       	st	X, r24
     190:	77 c0       	rjmp	.+238    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     192:	8b 81       	ldd	r24, Y+3	; 0x03
     194:	88 23       	and	r24, r24
     196:	09 f0       	breq	.+2      	; 0x19a <DIO_VidSetPinDirection+0x108>
     198:	73 c0       	rjmp	.+230    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     19a:	89 81       	ldd	r24, Y+1	; 0x01
     19c:	28 2f       	mov	r18, r24
     19e:	30 e0       	ldi	r19, 0x00	; 0
     1a0:	3d 83       	std	Y+5, r19	; 0x05
     1a2:	2c 83       	std	Y+4, r18	; 0x04
     1a4:	8c 81       	ldd	r24, Y+4	; 0x04
     1a6:	9d 81       	ldd	r25, Y+5	; 0x05
     1a8:	81 30       	cpi	r24, 0x01	; 1
     1aa:	91 05       	cpc	r25, r1
     1ac:	59 f1       	breq	.+86     	; 0x204 <DIO_VidSetPinDirection+0x172>
     1ae:	2c 81       	ldd	r18, Y+4	; 0x04
     1b0:	3d 81       	ldd	r19, Y+5	; 0x05
     1b2:	22 30       	cpi	r18, 0x02	; 2
     1b4:	31 05       	cpc	r19, r1
     1b6:	2c f4       	brge	.+10     	; 0x1c2 <DIO_VidSetPinDirection+0x130>
     1b8:	8c 81       	ldd	r24, Y+4	; 0x04
     1ba:	9d 81       	ldd	r25, Y+5	; 0x05
     1bc:	00 97       	sbiw	r24, 0x00	; 0
     1be:	69 f0       	breq	.+26     	; 0x1da <DIO_VidSetPinDirection+0x148>
     1c0:	5f c0       	rjmp	.+190    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     1c2:	2c 81       	ldd	r18, Y+4	; 0x04
     1c4:	3d 81       	ldd	r19, Y+5	; 0x05
     1c6:	22 30       	cpi	r18, 0x02	; 2
     1c8:	31 05       	cpc	r19, r1
     1ca:	89 f1       	breq	.+98     	; 0x22e <DIO_VidSetPinDirection+0x19c>
     1cc:	8c 81       	ldd	r24, Y+4	; 0x04
     1ce:	9d 81       	ldd	r25, Y+5	; 0x05
     1d0:	83 30       	cpi	r24, 0x03	; 3
     1d2:	91 05       	cpc	r25, r1
     1d4:	09 f4       	brne	.+2      	; 0x1d8 <DIO_VidSetPinDirection+0x146>
     1d6:	40 c0       	rjmp	.+128    	; 0x258 <DIO_VidSetPinDirection+0x1c6>
     1d8:	53 c0       	rjmp	.+166    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     1da:	aa e3       	ldi	r26, 0x3A	; 58
     1dc:	b0 e0       	ldi	r27, 0x00	; 0
     1de:	ea e3       	ldi	r30, 0x3A	; 58
     1e0:	f0 e0       	ldi	r31, 0x00	; 0
     1e2:	80 81       	ld	r24, Z
     1e4:	48 2f       	mov	r20, r24
     1e6:	8a 81       	ldd	r24, Y+2	; 0x02
     1e8:	28 2f       	mov	r18, r24
     1ea:	30 e0       	ldi	r19, 0x00	; 0
     1ec:	81 e0       	ldi	r24, 0x01	; 1
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	02 2e       	mov	r0, r18
     1f2:	02 c0       	rjmp	.+4      	; 0x1f8 <DIO_VidSetPinDirection+0x166>
     1f4:	88 0f       	add	r24, r24
     1f6:	99 1f       	adc	r25, r25
     1f8:	0a 94       	dec	r0
     1fa:	e2 f7       	brpl	.-8      	; 0x1f4 <DIO_VidSetPinDirection+0x162>
     1fc:	80 95       	com	r24
     1fe:	84 23       	and	r24, r20
     200:	8c 93       	st	X, r24
     202:	3e c0       	rjmp	.+124    	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     204:	a7 e3       	ldi	r26, 0x37	; 55
     206:	b0 e0       	ldi	r27, 0x00	; 0
     208:	e7 e3       	ldi	r30, 0x37	; 55
     20a:	f0 e0       	ldi	r31, 0x00	; 0
     20c:	80 81       	ld	r24, Z
     20e:	48 2f       	mov	r20, r24
     210:	8a 81       	ldd	r24, Y+2	; 0x02
     212:	28 2f       	mov	r18, r24
     214:	30 e0       	ldi	r19, 0x00	; 0
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_VidSetPinDirection+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_VidSetPinDirection+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	29 c0       	rjmp	.+82     	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     22e:	a4 e3       	ldi	r26, 0x34	; 52
     230:	b0 e0       	ldi	r27, 0x00	; 0
     232:	e4 e3       	ldi	r30, 0x34	; 52
     234:	f0 e0       	ldi	r31, 0x00	; 0
     236:	80 81       	ld	r24, Z
     238:	48 2f       	mov	r20, r24
     23a:	8a 81       	ldd	r24, Y+2	; 0x02
     23c:	28 2f       	mov	r18, r24
     23e:	30 e0       	ldi	r19, 0x00	; 0
     240:	81 e0       	ldi	r24, 0x01	; 1
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	02 2e       	mov	r0, r18
     246:	02 c0       	rjmp	.+4      	; 0x24c <DIO_VidSetPinDirection+0x1ba>
     248:	88 0f       	add	r24, r24
     24a:	99 1f       	adc	r25, r25
     24c:	0a 94       	dec	r0
     24e:	e2 f7       	brpl	.-8      	; 0x248 <DIO_VidSetPinDirection+0x1b6>
     250:	80 95       	com	r24
     252:	84 23       	and	r24, r20
     254:	8c 93       	st	X, r24
     256:	14 c0       	rjmp	.+40     	; 0x280 <DIO_VidSetPinDirection+0x1ee>
     258:	a1 e3       	ldi	r26, 0x31	; 49
     25a:	b0 e0       	ldi	r27, 0x00	; 0
     25c:	e1 e3       	ldi	r30, 0x31	; 49
     25e:	f0 e0       	ldi	r31, 0x00	; 0
     260:	80 81       	ld	r24, Z
     262:	48 2f       	mov	r20, r24
     264:	8a 81       	ldd	r24, Y+2	; 0x02
     266:	28 2f       	mov	r18, r24
     268:	30 e0       	ldi	r19, 0x00	; 0
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	02 2e       	mov	r0, r18
     270:	02 c0       	rjmp	.+4      	; 0x276 <DIO_VidSetPinDirection+0x1e4>
     272:	88 0f       	add	r24, r24
     274:	99 1f       	adc	r25, r25
     276:	0a 94       	dec	r0
     278:	e2 f7       	brpl	.-8      	; 0x272 <DIO_VidSetPinDirection+0x1e0>
     27a:	80 95       	com	r24
     27c:	84 23       	and	r24, r20
     27e:	8c 93       	st	X, r24
     280:	27 96       	adiw	r28, 0x07	; 7
     282:	0f b6       	in	r0, 0x3f	; 63
     284:	f8 94       	cli
     286:	de bf       	out	0x3e, r29	; 62
     288:	0f be       	out	0x3f, r0	; 63
     28a:	cd bf       	out	0x3d, r28	; 61
     28c:	cf 91       	pop	r28
     28e:	df 91       	pop	r29
     290:	08 95       	ret

00000292 <DIO_VidSetPinValue>:
		
	}
	
}
void DIO_VidSetPinValue			(u8 copy_u8port, u8 copy_U8pin, u8 copy_U8value)
{
     292:	df 93       	push	r29
     294:	cf 93       	push	r28
     296:	cd b7       	in	r28, 0x3d	; 61
     298:	de b7       	in	r29, 0x3e	; 62
     29a:	27 97       	sbiw	r28, 0x07	; 7
     29c:	0f b6       	in	r0, 0x3f	; 63
     29e:	f8 94       	cli
     2a0:	de bf       	out	0x3e, r29	; 62
     2a2:	0f be       	out	0x3f, r0	; 63
     2a4:	cd bf       	out	0x3d, r28	; 61
     2a6:	89 83       	std	Y+1, r24	; 0x01
     2a8:	6a 83       	std	Y+2, r22	; 0x02
     2aa:	4b 83       	std	Y+3, r20	; 0x03
	if(HIGH==copy_U8value)
     2ac:	8b 81       	ldd	r24, Y+3	; 0x03
     2ae:	81 30       	cpi	r24, 0x01	; 1
     2b0:	09 f0       	breq	.+2      	; 0x2b4 <DIO_VidSetPinValue+0x22>
     2b2:	6f c0       	rjmp	.+222    	; 0x392 <DIO_VidSetPinValue+0x100>
	{
		switch (copy_u8port)
     2b4:	89 81       	ldd	r24, Y+1	; 0x01
     2b6:	28 2f       	mov	r18, r24
     2b8:	30 e0       	ldi	r19, 0x00	; 0
     2ba:	3f 83       	std	Y+7, r19	; 0x07
     2bc:	2e 83       	std	Y+6, r18	; 0x06
     2be:	8e 81       	ldd	r24, Y+6	; 0x06
     2c0:	9f 81       	ldd	r25, Y+7	; 0x07
     2c2:	81 30       	cpi	r24, 0x01	; 1
     2c4:	91 05       	cpc	r25, r1
     2c6:	49 f1       	breq	.+82     	; 0x31a <DIO_VidSetPinValue+0x88>
     2c8:	2e 81       	ldd	r18, Y+6	; 0x06
     2ca:	3f 81       	ldd	r19, Y+7	; 0x07
     2cc:	22 30       	cpi	r18, 0x02	; 2
     2ce:	31 05       	cpc	r19, r1
     2d0:	2c f4       	brge	.+10     	; 0x2dc <DIO_VidSetPinValue+0x4a>
     2d2:	8e 81       	ldd	r24, Y+6	; 0x06
     2d4:	9f 81       	ldd	r25, Y+7	; 0x07
     2d6:	00 97       	sbiw	r24, 0x00	; 0
     2d8:	61 f0       	breq	.+24     	; 0x2f2 <DIO_VidSetPinValue+0x60>
     2da:	d2 c0       	rjmp	.+420    	; 0x480 <DIO_VidSetPinValue+0x1ee>
     2dc:	2e 81       	ldd	r18, Y+6	; 0x06
     2de:	3f 81       	ldd	r19, Y+7	; 0x07
     2e0:	22 30       	cpi	r18, 0x02	; 2
     2e2:	31 05       	cpc	r19, r1
     2e4:	71 f1       	breq	.+92     	; 0x342 <DIO_VidSetPinValue+0xb0>
     2e6:	8e 81       	ldd	r24, Y+6	; 0x06
     2e8:	9f 81       	ldd	r25, Y+7	; 0x07
     2ea:	83 30       	cpi	r24, 0x03	; 3
     2ec:	91 05       	cpc	r25, r1
     2ee:	e9 f1       	breq	.+122    	; 0x36a <DIO_VidSetPinValue+0xd8>
     2f0:	c7 c0       	rjmp	.+398    	; 0x480 <DIO_VidSetPinValue+0x1ee>
		{
			case PORTA:SET_BIT(PORT_A, copy_U8pin); break;
     2f2:	ab e3       	ldi	r26, 0x3B	; 59
     2f4:	b0 e0       	ldi	r27, 0x00	; 0
     2f6:	eb e3       	ldi	r30, 0x3B	; 59
     2f8:	f0 e0       	ldi	r31, 0x00	; 0
     2fa:	80 81       	ld	r24, Z
     2fc:	48 2f       	mov	r20, r24
     2fe:	8a 81       	ldd	r24, Y+2	; 0x02
     300:	28 2f       	mov	r18, r24
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	81 e0       	ldi	r24, 0x01	; 1
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	02 2e       	mov	r0, r18
     30a:	02 c0       	rjmp	.+4      	; 0x310 <DIO_VidSetPinValue+0x7e>
     30c:	88 0f       	add	r24, r24
     30e:	99 1f       	adc	r25, r25
     310:	0a 94       	dec	r0
     312:	e2 f7       	brpl	.-8      	; 0x30c <DIO_VidSetPinValue+0x7a>
     314:	84 2b       	or	r24, r20
     316:	8c 93       	st	X, r24
     318:	b3 c0       	rjmp	.+358    	; 0x480 <DIO_VidSetPinValue+0x1ee>
			case PORTB:SET_BIT(PORT_B, copy_U8pin); break;
     31a:	a8 e3       	ldi	r26, 0x38	; 56
     31c:	b0 e0       	ldi	r27, 0x00	; 0
     31e:	e8 e3       	ldi	r30, 0x38	; 56
     320:	f0 e0       	ldi	r31, 0x00	; 0
     322:	80 81       	ld	r24, Z
     324:	48 2f       	mov	r20, r24
     326:	8a 81       	ldd	r24, Y+2	; 0x02
     328:	28 2f       	mov	r18, r24
     32a:	30 e0       	ldi	r19, 0x00	; 0
     32c:	81 e0       	ldi	r24, 0x01	; 1
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	02 2e       	mov	r0, r18
     332:	02 c0       	rjmp	.+4      	; 0x338 <DIO_VidSetPinValue+0xa6>
     334:	88 0f       	add	r24, r24
     336:	99 1f       	adc	r25, r25
     338:	0a 94       	dec	r0
     33a:	e2 f7       	brpl	.-8      	; 0x334 <DIO_VidSetPinValue+0xa2>
     33c:	84 2b       	or	r24, r20
     33e:	8c 93       	st	X, r24
     340:	9f c0       	rjmp	.+318    	; 0x480 <DIO_VidSetPinValue+0x1ee>
			case PORTC:SET_BIT(PORT_C, copy_U8pin); break;
     342:	a5 e3       	ldi	r26, 0x35	; 53
     344:	b0 e0       	ldi	r27, 0x00	; 0
     346:	e5 e3       	ldi	r30, 0x35	; 53
     348:	f0 e0       	ldi	r31, 0x00	; 0
     34a:	80 81       	ld	r24, Z
     34c:	48 2f       	mov	r20, r24
     34e:	8a 81       	ldd	r24, Y+2	; 0x02
     350:	28 2f       	mov	r18, r24
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	02 2e       	mov	r0, r18
     35a:	02 c0       	rjmp	.+4      	; 0x360 <DIO_VidSetPinValue+0xce>
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	0a 94       	dec	r0
     362:	e2 f7       	brpl	.-8      	; 0x35c <DIO_VidSetPinValue+0xca>
     364:	84 2b       	or	r24, r20
     366:	8c 93       	st	X, r24
     368:	8b c0       	rjmp	.+278    	; 0x480 <DIO_VidSetPinValue+0x1ee>
			case PORTD:SET_BIT(PORT_D, copy_U8pin); break;
     36a:	a2 e3       	ldi	r26, 0x32	; 50
     36c:	b0 e0       	ldi	r27, 0x00	; 0
     36e:	e2 e3       	ldi	r30, 0x32	; 50
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8a 81       	ldd	r24, Y+2	; 0x02
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_VidSetPinValue+0xf6>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_VidSetPinValue+0xf2>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
     390:	77 c0       	rjmp	.+238    	; 0x480 <DIO_VidSetPinValue+0x1ee>
	
		}	
	}
	else if(LOW==copy_U8value)
     392:	8b 81       	ldd	r24, Y+3	; 0x03
     394:	88 23       	and	r24, r24
     396:	09 f0       	breq	.+2      	; 0x39a <DIO_VidSetPinValue+0x108>
     398:	73 c0       	rjmp	.+230    	; 0x480 <DIO_VidSetPinValue+0x1ee>
	{
		switch(copy_u8port)
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	28 2f       	mov	r18, r24
     39e:	30 e0       	ldi	r19, 0x00	; 0
     3a0:	3d 83       	std	Y+5, r19	; 0x05
     3a2:	2c 83       	std	Y+4, r18	; 0x04
     3a4:	8c 81       	ldd	r24, Y+4	; 0x04
     3a6:	9d 81       	ldd	r25, Y+5	; 0x05
     3a8:	81 30       	cpi	r24, 0x01	; 1
     3aa:	91 05       	cpc	r25, r1
     3ac:	59 f1       	breq	.+86     	; 0x404 <DIO_VidSetPinValue+0x172>
     3ae:	2c 81       	ldd	r18, Y+4	; 0x04
     3b0:	3d 81       	ldd	r19, Y+5	; 0x05
     3b2:	22 30       	cpi	r18, 0x02	; 2
     3b4:	31 05       	cpc	r19, r1
     3b6:	2c f4       	brge	.+10     	; 0x3c2 <DIO_VidSetPinValue+0x130>
     3b8:	8c 81       	ldd	r24, Y+4	; 0x04
     3ba:	9d 81       	ldd	r25, Y+5	; 0x05
     3bc:	00 97       	sbiw	r24, 0x00	; 0
     3be:	69 f0       	breq	.+26     	; 0x3da <DIO_VidSetPinValue+0x148>
     3c0:	5f c0       	rjmp	.+190    	; 0x480 <DIO_VidSetPinValue+0x1ee>
     3c2:	2c 81       	ldd	r18, Y+4	; 0x04
     3c4:	3d 81       	ldd	r19, Y+5	; 0x05
     3c6:	22 30       	cpi	r18, 0x02	; 2
     3c8:	31 05       	cpc	r19, r1
     3ca:	89 f1       	breq	.+98     	; 0x42e <DIO_VidSetPinValue+0x19c>
     3cc:	8c 81       	ldd	r24, Y+4	; 0x04
     3ce:	9d 81       	ldd	r25, Y+5	; 0x05
     3d0:	83 30       	cpi	r24, 0x03	; 3
     3d2:	91 05       	cpc	r25, r1
     3d4:	09 f4       	brne	.+2      	; 0x3d8 <DIO_VidSetPinValue+0x146>
     3d6:	40 c0       	rjmp	.+128    	; 0x458 <DIO_VidSetPinValue+0x1c6>
     3d8:	53 c0       	rjmp	.+166    	; 0x480 <DIO_VidSetPinValue+0x1ee>
		{
			case PORTA:CLR_BIT(PORT_A, copy_U8pin); break;
     3da:	ab e3       	ldi	r26, 0x3B	; 59
     3dc:	b0 e0       	ldi	r27, 0x00	; 0
     3de:	eb e3       	ldi	r30, 0x3B	; 59
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	80 81       	ld	r24, Z
     3e4:	48 2f       	mov	r20, r24
     3e6:	8a 81       	ldd	r24, Y+2	; 0x02
     3e8:	28 2f       	mov	r18, r24
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	81 e0       	ldi	r24, 0x01	; 1
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	02 2e       	mov	r0, r18
     3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <DIO_VidSetPinValue+0x166>
     3f4:	88 0f       	add	r24, r24
     3f6:	99 1f       	adc	r25, r25
     3f8:	0a 94       	dec	r0
     3fa:	e2 f7       	brpl	.-8      	; 0x3f4 <DIO_VidSetPinValue+0x162>
     3fc:	80 95       	com	r24
     3fe:	84 23       	and	r24, r20
     400:	8c 93       	st	X, r24
     402:	3e c0       	rjmp	.+124    	; 0x480 <DIO_VidSetPinValue+0x1ee>
			case PORTB:CLR_BIT(PORT_B, copy_U8pin); break;
     404:	a8 e3       	ldi	r26, 0x38	; 56
     406:	b0 e0       	ldi	r27, 0x00	; 0
     408:	e8 e3       	ldi	r30, 0x38	; 56
     40a:	f0 e0       	ldi	r31, 0x00	; 0
     40c:	80 81       	ld	r24, Z
     40e:	48 2f       	mov	r20, r24
     410:	8a 81       	ldd	r24, Y+2	; 0x02
     412:	28 2f       	mov	r18, r24
     414:	30 e0       	ldi	r19, 0x00	; 0
     416:	81 e0       	ldi	r24, 0x01	; 1
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	02 2e       	mov	r0, r18
     41c:	02 c0       	rjmp	.+4      	; 0x422 <DIO_VidSetPinValue+0x190>
     41e:	88 0f       	add	r24, r24
     420:	99 1f       	adc	r25, r25
     422:	0a 94       	dec	r0
     424:	e2 f7       	brpl	.-8      	; 0x41e <DIO_VidSetPinValue+0x18c>
     426:	80 95       	com	r24
     428:	84 23       	and	r24, r20
     42a:	8c 93       	st	X, r24
     42c:	29 c0       	rjmp	.+82     	; 0x480 <DIO_VidSetPinValue+0x1ee>
		    case PORTC:CLR_BIT(PORT_C, copy_U8pin); break;
     42e:	a5 e3       	ldi	r26, 0x35	; 53
     430:	b0 e0       	ldi	r27, 0x00	; 0
     432:	e5 e3       	ldi	r30, 0x35	; 53
     434:	f0 e0       	ldi	r31, 0x00	; 0
     436:	80 81       	ld	r24, Z
     438:	48 2f       	mov	r20, r24
     43a:	8a 81       	ldd	r24, Y+2	; 0x02
     43c:	28 2f       	mov	r18, r24
     43e:	30 e0       	ldi	r19, 0x00	; 0
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	02 2e       	mov	r0, r18
     446:	02 c0       	rjmp	.+4      	; 0x44c <DIO_VidSetPinValue+0x1ba>
     448:	88 0f       	add	r24, r24
     44a:	99 1f       	adc	r25, r25
     44c:	0a 94       	dec	r0
     44e:	e2 f7       	brpl	.-8      	; 0x448 <DIO_VidSetPinValue+0x1b6>
     450:	80 95       	com	r24
     452:	84 23       	and	r24, r20
     454:	8c 93       	st	X, r24
     456:	14 c0       	rjmp	.+40     	; 0x480 <DIO_VidSetPinValue+0x1ee>
		    case PORTD:CLR_BIT(PORT_D, copy_U8pin); break;
     458:	a2 e3       	ldi	r26, 0x32	; 50
     45a:	b0 e0       	ldi	r27, 0x00	; 0
     45c:	e2 e3       	ldi	r30, 0x32	; 50
     45e:	f0 e0       	ldi	r31, 0x00	; 0
     460:	80 81       	ld	r24, Z
     462:	48 2f       	mov	r20, r24
     464:	8a 81       	ldd	r24, Y+2	; 0x02
     466:	28 2f       	mov	r18, r24
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	02 2e       	mov	r0, r18
     470:	02 c0       	rjmp	.+4      	; 0x476 <DIO_VidSetPinValue+0x1e4>
     472:	88 0f       	add	r24, r24
     474:	99 1f       	adc	r25, r25
     476:	0a 94       	dec	r0
     478:	e2 f7       	brpl	.-8      	; 0x472 <DIO_VidSetPinValue+0x1e0>
     47a:	80 95       	com	r24
     47c:	84 23       	and	r24, r20
     47e:	8c 93       	st	X, r24
		
	}	
	
	
	
}
     480:	27 96       	adiw	r28, 0x07	; 7
     482:	0f b6       	in	r0, 0x3f	; 63
     484:	f8 94       	cli
     486:	de bf       	out	0x3e, r29	; 62
     488:	0f be       	out	0x3f, r0	; 63
     48a:	cd bf       	out	0x3d, r28	; 61
     48c:	cf 91       	pop	r28
     48e:	df 91       	pop	r29
     490:	08 95       	ret

00000492 <DIO_VidGetPinValue>:


u8 DIO_VidGetPinValue			(u8 copy_u8port, u8 Copy_U8Pin)
{
     492:	df 93       	push	r29
     494:	cf 93       	push	r28
     496:	00 d0       	rcall	.+0      	; 0x498 <DIO_VidGetPinValue+0x6>
     498:	00 d0       	rcall	.+0      	; 0x49a <DIO_VidGetPinValue+0x8>
     49a:	0f 92       	push	r0
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
     4a0:	8a 83       	std	Y+2, r24	; 0x02
     4a2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Lcal_U8PinResult=0;
     4a4:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8port){
     4a6:	8a 81       	ldd	r24, Y+2	; 0x02
     4a8:	28 2f       	mov	r18, r24
     4aa:	30 e0       	ldi	r19, 0x00	; 0
     4ac:	3d 83       	std	Y+5, r19	; 0x05
     4ae:	2c 83       	std	Y+4, r18	; 0x04
     4b0:	4c 81       	ldd	r20, Y+4	; 0x04
     4b2:	5d 81       	ldd	r21, Y+5	; 0x05
     4b4:	41 30       	cpi	r20, 0x01	; 1
     4b6:	51 05       	cpc	r21, r1
     4b8:	41 f1       	breq	.+80     	; 0x50a <DIO_VidGetPinValue+0x78>
     4ba:	8c 81       	ldd	r24, Y+4	; 0x04
     4bc:	9d 81       	ldd	r25, Y+5	; 0x05
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	91 05       	cpc	r25, r1
     4c2:	34 f4       	brge	.+12     	; 0x4d0 <DIO_VidGetPinValue+0x3e>
     4c4:	2c 81       	ldd	r18, Y+4	; 0x04
     4c6:	3d 81       	ldd	r19, Y+5	; 0x05
     4c8:	21 15       	cp	r18, r1
     4ca:	31 05       	cpc	r19, r1
     4cc:	61 f0       	breq	.+24     	; 0x4e6 <DIO_VidGetPinValue+0x54>
     4ce:	52 c0       	rjmp	.+164    	; 0x574 <DIO_VidGetPinValue+0xe2>
     4d0:	4c 81       	ldd	r20, Y+4	; 0x04
     4d2:	5d 81       	ldd	r21, Y+5	; 0x05
     4d4:	42 30       	cpi	r20, 0x02	; 2
     4d6:	51 05       	cpc	r21, r1
     4d8:	51 f1       	breq	.+84     	; 0x52e <DIO_VidGetPinValue+0x9c>
     4da:	8c 81       	ldd	r24, Y+4	; 0x04
     4dc:	9d 81       	ldd	r25, Y+5	; 0x05
     4de:	83 30       	cpi	r24, 0x03	; 3
     4e0:	91 05       	cpc	r25, r1
     4e2:	b9 f1       	breq	.+110    	; 0x552 <DIO_VidGetPinValue+0xc0>
     4e4:	47 c0       	rjmp	.+142    	; 0x574 <DIO_VidGetPinValue+0xe2>

			case PORTA :		Lcal_U8PinResult=GET_BIT(PINA,Copy_U8Pin);	        break;
     4e6:	e9 e3       	ldi	r30, 0x39	; 57
     4e8:	f0 e0       	ldi	r31, 0x00	; 0
     4ea:	80 81       	ld	r24, Z
     4ec:	28 2f       	mov	r18, r24
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	8b 81       	ldd	r24, Y+3	; 0x03
     4f2:	88 2f       	mov	r24, r24
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	a9 01       	movw	r20, r18
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <DIO_VidGetPinValue+0x6c>
     4fa:	55 95       	asr	r21
     4fc:	47 95       	ror	r20
     4fe:	8a 95       	dec	r24
     500:	e2 f7       	brpl	.-8      	; 0x4fa <DIO_VidGetPinValue+0x68>
     502:	ca 01       	movw	r24, r20
     504:	81 70       	andi	r24, 0x01	; 1
     506:	89 83       	std	Y+1, r24	; 0x01
     508:	35 c0       	rjmp	.+106    	; 0x574 <DIO_VidGetPinValue+0xe2>
			case PORTB :		Lcal_U8PinResult=GET_BIT(PINB,Copy_U8Pin); 		    break;
     50a:	e6 e3       	ldi	r30, 0x36	; 54
     50c:	f0 e0       	ldi	r31, 0x00	; 0
     50e:	80 81       	ld	r24, Z
     510:	28 2f       	mov	r18, r24
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	8b 81       	ldd	r24, Y+3	; 0x03
     516:	88 2f       	mov	r24, r24
     518:	90 e0       	ldi	r25, 0x00	; 0
     51a:	a9 01       	movw	r20, r18
     51c:	02 c0       	rjmp	.+4      	; 0x522 <DIO_VidGetPinValue+0x90>
     51e:	55 95       	asr	r21
     520:	47 95       	ror	r20
     522:	8a 95       	dec	r24
     524:	e2 f7       	brpl	.-8      	; 0x51e <DIO_VidGetPinValue+0x8c>
     526:	ca 01       	movw	r24, r20
     528:	81 70       	andi	r24, 0x01	; 1
     52a:	89 83       	std	Y+1, r24	; 0x01
     52c:	23 c0       	rjmp	.+70     	; 0x574 <DIO_VidGetPinValue+0xe2>
			case PORTC :		Lcal_U8PinResult=GET_BIT(PINC,Copy_U8Pin);			break;
     52e:	e3 e3       	ldi	r30, 0x33	; 51
     530:	f0 e0       	ldi	r31, 0x00	; 0
     532:	80 81       	ld	r24, Z
     534:	28 2f       	mov	r18, r24
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	88 2f       	mov	r24, r24
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	a9 01       	movw	r20, r18
     540:	02 c0       	rjmp	.+4      	; 0x546 <DIO_VidGetPinValue+0xb4>
     542:	55 95       	asr	r21
     544:	47 95       	ror	r20
     546:	8a 95       	dec	r24
     548:	e2 f7       	brpl	.-8      	; 0x542 <DIO_VidGetPinValue+0xb0>
     54a:	ca 01       	movw	r24, r20
     54c:	81 70       	andi	r24, 0x01	; 1
     54e:	89 83       	std	Y+1, r24	; 0x01
     550:	11 c0       	rjmp	.+34     	; 0x574 <DIO_VidGetPinValue+0xe2>
			case PORTD :		Lcal_U8PinResult=GET_BIT(PIND,Copy_U8Pin);			break;
     552:	e0 e3       	ldi	r30, 0x30	; 48
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	80 81       	ld	r24, Z
     558:	28 2f       	mov	r18, r24
     55a:	30 e0       	ldi	r19, 0x00	; 0
     55c:	8b 81       	ldd	r24, Y+3	; 0x03
     55e:	88 2f       	mov	r24, r24
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	a9 01       	movw	r20, r18
     564:	02 c0       	rjmp	.+4      	; 0x56a <DIO_VidGetPinValue+0xd8>
     566:	55 95       	asr	r21
     568:	47 95       	ror	r20
     56a:	8a 95       	dec	r24
     56c:	e2 f7       	brpl	.-8      	; 0x566 <DIO_VidGetPinValue+0xd4>
     56e:	ca 01       	movw	r24, r20
     570:	81 70       	andi	r24, 0x01	; 1
     572:	89 83       	std	Y+1, r24	; 0x01

			}


return(Lcal_U8PinResult);
     574:	89 81       	ldd	r24, Y+1	; 0x01
	
	
}
     576:	0f 90       	pop	r0
     578:	0f 90       	pop	r0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <DIO_VidSetPortDirection>:

void DIO_VidSetPortDirection	(u8 copy_u8port, u8 copy_U8state)
{
     586:	df 93       	push	r29
     588:	cf 93       	push	r28
     58a:	00 d0       	rcall	.+0      	; 0x58c <DIO_VidSetPortDirection+0x6>
     58c:	00 d0       	rcall	.+0      	; 0x58e <DIO_VidSetPortDirection+0x8>
     58e:	00 d0       	rcall	.+0      	; 0x590 <DIO_VidSetPortDirection+0xa>
     590:	cd b7       	in	r28, 0x3d	; 61
     592:	de b7       	in	r29, 0x3e	; 62
     594:	89 83       	std	Y+1, r24	; 0x01
     596:	6a 83       	std	Y+2, r22	; 0x02
	
	if(OUTPUT==copy_U8state)
     598:	8a 81       	ldd	r24, Y+2	; 0x02
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	99 f5       	brne	.+102    	; 0x604 <DIO_VidSetPortDirection+0x7e>
	{
		switch (copy_u8port)
     59e:	89 81       	ldd	r24, Y+1	; 0x01
     5a0:	28 2f       	mov	r18, r24
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	3e 83       	std	Y+6, r19	; 0x06
     5a6:	2d 83       	std	Y+5, r18	; 0x05
     5a8:	8d 81       	ldd	r24, Y+5	; 0x05
     5aa:	9e 81       	ldd	r25, Y+6	; 0x06
     5ac:	81 30       	cpi	r24, 0x01	; 1
     5ae:	91 05       	cpc	r25, r1
     5b0:	d1 f0       	breq	.+52     	; 0x5e6 <DIO_VidSetPortDirection+0x60>
     5b2:	2d 81       	ldd	r18, Y+5	; 0x05
     5b4:	3e 81       	ldd	r19, Y+6	; 0x06
     5b6:	22 30       	cpi	r18, 0x02	; 2
     5b8:	31 05       	cpc	r19, r1
     5ba:	2c f4       	brge	.+10     	; 0x5c6 <DIO_VidSetPortDirection+0x40>
     5bc:	8d 81       	ldd	r24, Y+5	; 0x05
     5be:	9e 81       	ldd	r25, Y+6	; 0x06
     5c0:	00 97       	sbiw	r24, 0x00	; 0
     5c2:	61 f0       	breq	.+24     	; 0x5dc <DIO_VidSetPortDirection+0x56>
     5c4:	50 c0       	rjmp	.+160    	; 0x666 <DIO_VidSetPortDirection+0xe0>
     5c6:	2d 81       	ldd	r18, Y+5	; 0x05
     5c8:	3e 81       	ldd	r19, Y+6	; 0x06
     5ca:	22 30       	cpi	r18, 0x02	; 2
     5cc:	31 05       	cpc	r19, r1
     5ce:	81 f0       	breq	.+32     	; 0x5f0 <DIO_VidSetPortDirection+0x6a>
     5d0:	8d 81       	ldd	r24, Y+5	; 0x05
     5d2:	9e 81       	ldd	r25, Y+6	; 0x06
     5d4:	83 30       	cpi	r24, 0x03	; 3
     5d6:	91 05       	cpc	r25, r1
     5d8:	81 f0       	breq	.+32     	; 0x5fa <DIO_VidSetPortDirection+0x74>
     5da:	45 c0       	rjmp	.+138    	; 0x666 <DIO_VidSetPortDirection+0xe0>
		{
			case PORTA:DDRA= ALL_OUTPUT		; break;
     5dc:	ea e3       	ldi	r30, 0x3A	; 58
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	8f ef       	ldi	r24, 0xFF	; 255
     5e2:	80 83       	st	Z, r24
     5e4:	40 c0       	rjmp	.+128    	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTB:DDRB= ALL_OUTPUT		; break;
     5e6:	e7 e3       	ldi	r30, 0x37	; 55
     5e8:	f0 e0       	ldi	r31, 0x00	; 0
     5ea:	8f ef       	ldi	r24, 0xFF	; 255
     5ec:	80 83       	st	Z, r24
     5ee:	3b c0       	rjmp	.+118    	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTC:DDRC= ALL_OUTPUT		; break;
     5f0:	e4 e3       	ldi	r30, 0x34	; 52
     5f2:	f0 e0       	ldi	r31, 0x00	; 0
     5f4:	8f ef       	ldi	r24, 0xFF	; 255
     5f6:	80 83       	st	Z, r24
     5f8:	36 c0       	rjmp	.+108    	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTD:DDRD= ALL_OUTPUT		; break;
     5fa:	e1 e3       	ldi	r30, 0x31	; 49
     5fc:	f0 e0       	ldi	r31, 0x00	; 0
     5fe:	8f ef       	ldi	r24, 0xFF	; 255
     600:	80 83       	st	Z, r24
     602:	31 c0       	rjmp	.+98     	; 0x666 <DIO_VidSetPortDirection+0xe0>
	
		}	
	}
	else if(INPUT==copy_U8state)
     604:	8a 81       	ldd	r24, Y+2	; 0x02
     606:	88 23       	and	r24, r24
     608:	71 f5       	brne	.+92     	; 0x666 <DIO_VidSetPortDirection+0xe0>
	{
		switch(copy_u8port)
     60a:	89 81       	ldd	r24, Y+1	; 0x01
     60c:	28 2f       	mov	r18, r24
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	3c 83       	std	Y+4, r19	; 0x04
     612:	2b 83       	std	Y+3, r18	; 0x03
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	9c 81       	ldd	r25, Y+4	; 0x04
     618:	81 30       	cpi	r24, 0x01	; 1
     61a:	91 05       	cpc	r25, r1
     61c:	c9 f0       	breq	.+50     	; 0x650 <DIO_VidSetPortDirection+0xca>
     61e:	2b 81       	ldd	r18, Y+3	; 0x03
     620:	3c 81       	ldd	r19, Y+4	; 0x04
     622:	22 30       	cpi	r18, 0x02	; 2
     624:	31 05       	cpc	r19, r1
     626:	2c f4       	brge	.+10     	; 0x632 <DIO_VidSetPortDirection+0xac>
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	9c 81       	ldd	r25, Y+4	; 0x04
     62c:	00 97       	sbiw	r24, 0x00	; 0
     62e:	61 f0       	breq	.+24     	; 0x648 <DIO_VidSetPortDirection+0xc2>
     630:	1a c0       	rjmp	.+52     	; 0x666 <DIO_VidSetPortDirection+0xe0>
     632:	2b 81       	ldd	r18, Y+3	; 0x03
     634:	3c 81       	ldd	r19, Y+4	; 0x04
     636:	22 30       	cpi	r18, 0x02	; 2
     638:	31 05       	cpc	r19, r1
     63a:	71 f0       	breq	.+28     	; 0x658 <DIO_VidSetPortDirection+0xd2>
     63c:	8b 81       	ldd	r24, Y+3	; 0x03
     63e:	9c 81       	ldd	r25, Y+4	; 0x04
     640:	83 30       	cpi	r24, 0x03	; 3
     642:	91 05       	cpc	r25, r1
     644:	69 f0       	breq	.+26     	; 0x660 <DIO_VidSetPortDirection+0xda>
     646:	0f c0       	rjmp	.+30     	; 0x666 <DIO_VidSetPortDirection+0xe0>
		{
			case PORTA:DDRA= ALL_INPUT		; break;
     648:	ea e3       	ldi	r30, 0x3A	; 58
     64a:	f0 e0       	ldi	r31, 0x00	; 0
     64c:	10 82       	st	Z, r1
     64e:	0b c0       	rjmp	.+22     	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTB:DDRB= ALL_INPUT		; break;
     650:	e7 e3       	ldi	r30, 0x37	; 55
     652:	f0 e0       	ldi	r31, 0x00	; 0
     654:	10 82       	st	Z, r1
     656:	07 c0       	rjmp	.+14     	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTC:DDRC= ALL_INPUT		; break;
     658:	e4 e3       	ldi	r30, 0x34	; 52
     65a:	f0 e0       	ldi	r31, 0x00	; 0
     65c:	10 82       	st	Z, r1
     65e:	03 c0       	rjmp	.+6      	; 0x666 <DIO_VidSetPortDirection+0xe0>
			case PORTD:DDRD= ALL_INPUT		; break;
     660:	e1 e3       	ldi	r30, 0x31	; 49
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	10 82       	st	Z, r1
	{
		
	}
	
	
}
     666:	26 96       	adiw	r28, 0x06	; 6
     668:	0f b6       	in	r0, 0x3f	; 63
     66a:	f8 94       	cli
     66c:	de bf       	out	0x3e, r29	; 62
     66e:	0f be       	out	0x3f, r0	; 63
     670:	cd bf       	out	0x3d, r28	; 61
     672:	cf 91       	pop	r28
     674:	df 91       	pop	r29
     676:	08 95       	ret

00000678 <DIO_VidSetPortValue>:
void DIO_VidSetPortValue		(u8 copy_u8port, u8 copy_U8value)
{
     678:	df 93       	push	r29
     67a:	cf 93       	push	r28
     67c:	00 d0       	rcall	.+0      	; 0x67e <DIO_VidSetPortValue+0x6>
     67e:	00 d0       	rcall	.+0      	; 0x680 <DIO_VidSetPortValue+0x8>
     680:	cd b7       	in	r28, 0x3d	; 61
     682:	de b7       	in	r29, 0x3e	; 62
     684:	89 83       	std	Y+1, r24	; 0x01
     686:	6a 83       	std	Y+2, r22	; 0x02
		
		switch (copy_u8port)
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	28 2f       	mov	r18, r24
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	3c 83       	std	Y+4, r19	; 0x04
     690:	2b 83       	std	Y+3, r18	; 0x03
     692:	8b 81       	ldd	r24, Y+3	; 0x03
     694:	9c 81       	ldd	r25, Y+4	; 0x04
     696:	81 30       	cpi	r24, 0x01	; 1
     698:	91 05       	cpc	r25, r1
     69a:	d1 f0       	breq	.+52     	; 0x6d0 <DIO_VidSetPortValue+0x58>
     69c:	2b 81       	ldd	r18, Y+3	; 0x03
     69e:	3c 81       	ldd	r19, Y+4	; 0x04
     6a0:	22 30       	cpi	r18, 0x02	; 2
     6a2:	31 05       	cpc	r19, r1
     6a4:	2c f4       	brge	.+10     	; 0x6b0 <DIO_VidSetPortValue+0x38>
     6a6:	8b 81       	ldd	r24, Y+3	; 0x03
     6a8:	9c 81       	ldd	r25, Y+4	; 0x04
     6aa:	00 97       	sbiw	r24, 0x00	; 0
     6ac:	61 f0       	breq	.+24     	; 0x6c6 <DIO_VidSetPortValue+0x4e>
     6ae:	1e c0       	rjmp	.+60     	; 0x6ec <DIO_VidSetPortValue+0x74>
     6b0:	2b 81       	ldd	r18, Y+3	; 0x03
     6b2:	3c 81       	ldd	r19, Y+4	; 0x04
     6b4:	22 30       	cpi	r18, 0x02	; 2
     6b6:	31 05       	cpc	r19, r1
     6b8:	81 f0       	breq	.+32     	; 0x6da <DIO_VidSetPortValue+0x62>
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	83 30       	cpi	r24, 0x03	; 3
     6c0:	91 05       	cpc	r25, r1
     6c2:	81 f0       	breq	.+32     	; 0x6e4 <DIO_VidSetPortValue+0x6c>
     6c4:	13 c0       	rjmp	.+38     	; 0x6ec <DIO_VidSetPortValue+0x74>
		{
			case PORTA:PORT_A=copy_U8value		; break;
     6c6:	eb e3       	ldi	r30, 0x3B	; 59
     6c8:	f0 e0       	ldi	r31, 0x00	; 0
     6ca:	8a 81       	ldd	r24, Y+2	; 0x02
     6cc:	80 83       	st	Z, r24
     6ce:	0e c0       	rjmp	.+28     	; 0x6ec <DIO_VidSetPortValue+0x74>
			case PORTB:PORT_B=copy_U8value		; break;
     6d0:	e8 e3       	ldi	r30, 0x38	; 56
     6d2:	f0 e0       	ldi	r31, 0x00	; 0
     6d4:	8a 81       	ldd	r24, Y+2	; 0x02
     6d6:	80 83       	st	Z, r24
     6d8:	09 c0       	rjmp	.+18     	; 0x6ec <DIO_VidSetPortValue+0x74>
			case PORTC:PORT_C=copy_U8value		; break;
     6da:	e5 e3       	ldi	r30, 0x35	; 53
     6dc:	f0 e0       	ldi	r31, 0x00	; 0
     6de:	8a 81       	ldd	r24, Y+2	; 0x02
     6e0:	80 83       	st	Z, r24
     6e2:	04 c0       	rjmp	.+8      	; 0x6ec <DIO_VidSetPortValue+0x74>
			case PORTD:PORT_D=copy_U8value		; break;
     6e4:	e2 e3       	ldi	r30, 0x32	; 50
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	8a 81       	ldd	r24, Y+2	; 0x02
     6ea:	80 83       	st	Z, r24
		}	
	
	
	
	
}
     6ec:	0f 90       	pop	r0
     6ee:	0f 90       	pop	r0
     6f0:	0f 90       	pop	r0
     6f2:	0f 90       	pop	r0
     6f4:	cf 91       	pop	r28
     6f6:	df 91       	pop	r29
     6f8:	08 95       	ret

000006fa <DIO_VidTogglePin>:

void DIO_VidTogglePin			(u8 copy_u8port, u8 copy_U8pin)
{
     6fa:	df 93       	push	r29
     6fc:	cf 93       	push	r28
     6fe:	00 d0       	rcall	.+0      	; 0x700 <DIO_VidTogglePin+0x6>
     700:	00 d0       	rcall	.+0      	; 0x702 <DIO_VidTogglePin+0x8>
     702:	cd b7       	in	r28, 0x3d	; 61
     704:	de b7       	in	r29, 0x3e	; 62
     706:	89 83       	std	Y+1, r24	; 0x01
     708:	6a 83       	std	Y+2, r22	; 0x02

		switch (copy_u8port)
     70a:	89 81       	ldd	r24, Y+1	; 0x01
     70c:	28 2f       	mov	r18, r24
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	3c 83       	std	Y+4, r19	; 0x04
     712:	2b 83       	std	Y+3, r18	; 0x03
     714:	8b 81       	ldd	r24, Y+3	; 0x03
     716:	9c 81       	ldd	r25, Y+4	; 0x04
     718:	81 30       	cpi	r24, 0x01	; 1
     71a:	91 05       	cpc	r25, r1
     71c:	49 f1       	breq	.+82     	; 0x770 <DIO_VidTogglePin+0x76>
     71e:	2b 81       	ldd	r18, Y+3	; 0x03
     720:	3c 81       	ldd	r19, Y+4	; 0x04
     722:	22 30       	cpi	r18, 0x02	; 2
     724:	31 05       	cpc	r19, r1
     726:	2c f4       	brge	.+10     	; 0x732 <DIO_VidTogglePin+0x38>
     728:	8b 81       	ldd	r24, Y+3	; 0x03
     72a:	9c 81       	ldd	r25, Y+4	; 0x04
     72c:	00 97       	sbiw	r24, 0x00	; 0
     72e:	61 f0       	breq	.+24     	; 0x748 <DIO_VidTogglePin+0x4e>
     730:	5a c0       	rjmp	.+180    	; 0x7e6 <DIO_VidTogglePin+0xec>
     732:	2b 81       	ldd	r18, Y+3	; 0x03
     734:	3c 81       	ldd	r19, Y+4	; 0x04
     736:	22 30       	cpi	r18, 0x02	; 2
     738:	31 05       	cpc	r19, r1
     73a:	71 f1       	breq	.+92     	; 0x798 <DIO_VidTogglePin+0x9e>
     73c:	8b 81       	ldd	r24, Y+3	; 0x03
     73e:	9c 81       	ldd	r25, Y+4	; 0x04
     740:	83 30       	cpi	r24, 0x03	; 3
     742:	91 05       	cpc	r25, r1
     744:	e9 f1       	breq	.+122    	; 0x7c0 <DIO_VidTogglePin+0xc6>
     746:	4f c0       	rjmp	.+158    	; 0x7e6 <DIO_VidTogglePin+0xec>
		{
					case PORTA:TOG_BIT(PORT_A, copy_U8pin); break;
     748:	ab e3       	ldi	r26, 0x3B	; 59
     74a:	b0 e0       	ldi	r27, 0x00	; 0
     74c:	eb e3       	ldi	r30, 0x3B	; 59
     74e:	f0 e0       	ldi	r31, 0x00	; 0
     750:	80 81       	ld	r24, Z
     752:	48 2f       	mov	r20, r24
     754:	8a 81       	ldd	r24, Y+2	; 0x02
     756:	28 2f       	mov	r18, r24
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	81 e0       	ldi	r24, 0x01	; 1
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	02 2e       	mov	r0, r18
     760:	02 c0       	rjmp	.+4      	; 0x766 <DIO_VidTogglePin+0x6c>
     762:	88 0f       	add	r24, r24
     764:	99 1f       	adc	r25, r25
     766:	0a 94       	dec	r0
     768:	e2 f7       	brpl	.-8      	; 0x762 <DIO_VidTogglePin+0x68>
     76a:	84 27       	eor	r24, r20
     76c:	8c 93       	st	X, r24
     76e:	3b c0       	rjmp	.+118    	; 0x7e6 <DIO_VidTogglePin+0xec>
					case PORTB:TOG_BIT(PORT_B, copy_U8pin); break;
     770:	a8 e3       	ldi	r26, 0x38	; 56
     772:	b0 e0       	ldi	r27, 0x00	; 0
     774:	e8 e3       	ldi	r30, 0x38	; 56
     776:	f0 e0       	ldi	r31, 0x00	; 0
     778:	80 81       	ld	r24, Z
     77a:	48 2f       	mov	r20, r24
     77c:	8a 81       	ldd	r24, Y+2	; 0x02
     77e:	28 2f       	mov	r18, r24
     780:	30 e0       	ldi	r19, 0x00	; 0
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	02 2e       	mov	r0, r18
     788:	02 c0       	rjmp	.+4      	; 0x78e <DIO_VidTogglePin+0x94>
     78a:	88 0f       	add	r24, r24
     78c:	99 1f       	adc	r25, r25
     78e:	0a 94       	dec	r0
     790:	e2 f7       	brpl	.-8      	; 0x78a <DIO_VidTogglePin+0x90>
     792:	84 27       	eor	r24, r20
     794:	8c 93       	st	X, r24
     796:	27 c0       	rjmp	.+78     	; 0x7e6 <DIO_VidTogglePin+0xec>
					case PORTC:TOG_BIT(PORT_C, copy_U8pin); break;
     798:	a5 e3       	ldi	r26, 0x35	; 53
     79a:	b0 e0       	ldi	r27, 0x00	; 0
     79c:	e5 e3       	ldi	r30, 0x35	; 53
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	48 2f       	mov	r20, r24
     7a4:	8a 81       	ldd	r24, Y+2	; 0x02
     7a6:	28 2f       	mov	r18, r24
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	81 e0       	ldi	r24, 0x01	; 1
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	02 2e       	mov	r0, r18
     7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <DIO_VidTogglePin+0xbc>
     7b2:	88 0f       	add	r24, r24
     7b4:	99 1f       	adc	r25, r25
     7b6:	0a 94       	dec	r0
     7b8:	e2 f7       	brpl	.-8      	; 0x7b2 <DIO_VidTogglePin+0xb8>
     7ba:	84 27       	eor	r24, r20
     7bc:	8c 93       	st	X, r24
     7be:	13 c0       	rjmp	.+38     	; 0x7e6 <DIO_VidTogglePin+0xec>
					case PORTD:TOG_BIT(PORT_D, copy_U8pin); break;
     7c0:	a2 e3       	ldi	r26, 0x32	; 50
     7c2:	b0 e0       	ldi	r27, 0x00	; 0
     7c4:	e2 e3       	ldi	r30, 0x32	; 50
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	80 81       	ld	r24, Z
     7ca:	48 2f       	mov	r20, r24
     7cc:	8a 81       	ldd	r24, Y+2	; 0x02
     7ce:	28 2f       	mov	r18, r24
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	02 2e       	mov	r0, r18
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <DIO_VidTogglePin+0xe4>
     7da:	88 0f       	add	r24, r24
     7dc:	99 1f       	adc	r25, r25
     7de:	0a 94       	dec	r0
     7e0:	e2 f7       	brpl	.-8      	; 0x7da <DIO_VidTogglePin+0xe0>
     7e2:	84 27       	eor	r24, r20
     7e4:	8c 93       	st	X, r24
		}

}
     7e6:	0f 90       	pop	r0
     7e8:	0f 90       	pop	r0
     7ea:	0f 90       	pop	r0
     7ec:	0f 90       	pop	r0
     7ee:	cf 91       	pop	r28
     7f0:	df 91       	pop	r29
     7f2:	08 95       	ret

000007f4 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 copy_u8port)
{
     7f4:	df 93       	push	r29
     7f6:	cf 93       	push	r28
     7f8:	00 d0       	rcall	.+0      	; 0x7fa <DIO_u8GetPortValue+0x6>
     7fa:	00 d0       	rcall	.+0      	; 0x7fc <DIO_u8GetPortValue+0x8>
     7fc:	cd b7       	in	r28, 0x3d	; 61
     7fe:	de b7       	in	r29, 0x3e	; 62
     800:	8a 83       	std	Y+2, r24	; 0x02
		u8 Lcal_U8PortResult=0;
     802:	19 82       	std	Y+1, r1	; 0x01
	switch(copy_u8port){
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	3c 83       	std	Y+4, r19	; 0x04
     80c:	2b 83       	std	Y+3, r18	; 0x03
     80e:	8b 81       	ldd	r24, Y+3	; 0x03
     810:	9c 81       	ldd	r25, Y+4	; 0x04
     812:	81 30       	cpi	r24, 0x01	; 1
     814:	91 05       	cpc	r25, r1
     816:	d1 f0       	breq	.+52     	; 0x84c <DIO_u8GetPortValue+0x58>
     818:	2b 81       	ldd	r18, Y+3	; 0x03
     81a:	3c 81       	ldd	r19, Y+4	; 0x04
     81c:	22 30       	cpi	r18, 0x02	; 2
     81e:	31 05       	cpc	r19, r1
     820:	2c f4       	brge	.+10     	; 0x82c <DIO_u8GetPortValue+0x38>
     822:	8b 81       	ldd	r24, Y+3	; 0x03
     824:	9c 81       	ldd	r25, Y+4	; 0x04
     826:	00 97       	sbiw	r24, 0x00	; 0
     828:	61 f0       	breq	.+24     	; 0x842 <DIO_u8GetPortValue+0x4e>
     82a:	1e c0       	rjmp	.+60     	; 0x868 <__stack+0x9>
     82c:	2b 81       	ldd	r18, Y+3	; 0x03
     82e:	3c 81       	ldd	r19, Y+4	; 0x04
     830:	22 30       	cpi	r18, 0x02	; 2
     832:	31 05       	cpc	r19, r1
     834:	81 f0       	breq	.+32     	; 0x856 <DIO_u8GetPortValue+0x62>
     836:	8b 81       	ldd	r24, Y+3	; 0x03
     838:	9c 81       	ldd	r25, Y+4	; 0x04
     83a:	83 30       	cpi	r24, 0x03	; 3
     83c:	91 05       	cpc	r25, r1
     83e:	81 f0       	breq	.+32     	; 0x860 <__stack+0x1>
     840:	13 c0       	rjmp	.+38     	; 0x868 <__stack+0x9>

			case PORTA :	Lcal_U8PortResult=PINA;	        break;
     842:	e9 e3       	ldi	r30, 0x39	; 57
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	80 81       	ld	r24, Z
     848:	89 83       	std	Y+1, r24	; 0x01
     84a:	0e c0       	rjmp	.+28     	; 0x868 <__stack+0x9>
			case PORTB :	Lcal_U8PortResult=PINB; 		    break;
     84c:	e6 e3       	ldi	r30, 0x36	; 54
     84e:	f0 e0       	ldi	r31, 0x00	; 0
     850:	80 81       	ld	r24, Z
     852:	89 83       	std	Y+1, r24	; 0x01
     854:	09 c0       	rjmp	.+18     	; 0x868 <__stack+0x9>
			case PORTC :	Lcal_U8PortResult=PINC;			break;
     856:	e3 e3       	ldi	r30, 0x33	; 51
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	80 81       	ld	r24, Z
     85c:	89 83       	std	Y+1, r24	; 0x01
     85e:	04 c0       	rjmp	.+8      	; 0x868 <__stack+0x9>
			case PORTD :	Lcal_U8PortResult=PIND;			break;
     860:	e0 e3       	ldi	r30, 0x30	; 48
     862:	f0 e0       	ldi	r31, 0x00	; 0
     864:	80 81       	ld	r24, Z
     866:	89 83       	std	Y+1, r24	; 0x01

			}


return(Lcal_U8PortResult);
     868:	89 81       	ldd	r24, Y+1	; 0x01
	
	
}
     86a:	0f 90       	pop	r0
     86c:	0f 90       	pop	r0
     86e:	0f 90       	pop	r0
     870:	0f 90       	pop	r0
     872:	cf 91       	pop	r28
     874:	df 91       	pop	r29
     876:	08 95       	ret

00000878 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     878:	df 93       	push	r29
     87a:	cf 93       	push	r28
     87c:	cd b7       	in	r28, 0x3d	; 61
     87e:	de b7       	in	r29, 0x3e	; 62
     880:	27 97       	sbiw	r28, 0x07	; 7
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	de bf       	out	0x3e, r29	; 62
     888:	0f be       	out	0x3f, r0	; 63
     88a:	cd bf       	out	0x3d, r28	; 61
     88c:	9d 83       	std	Y+5, r25	; 0x05
     88e:	8c 83       	std	Y+4, r24	; 0x04
     890:	6e 83       	std	Y+6, r22	; 0x06
     892:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     894:	8a e1       	ldi	r24, 0x1A	; 26
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	0e 94 14 07 	call	0xe28	; 0xe28 <pvPortMalloc>
     89c:	9a 83       	std	Y+2, r25	; 0x02
     89e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     8a0:	89 81       	ldd	r24, Y+1	; 0x01
     8a2:	9a 81       	ldd	r25, Y+2	; 0x02
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <xCoRoutineCreate+0x32>
     8a8:	6f c0       	rjmp	.+222    	; 0x988 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     8aa:	80 91 68 00 	lds	r24, 0x0068
     8ae:	90 91 69 00 	lds	r25, 0x0069
     8b2:	00 97       	sbiw	r24, 0x00	; 0
     8b4:	41 f4       	brne	.+16     	; 0x8c6 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     8b6:	89 81       	ldd	r24, Y+1	; 0x01
     8b8:	9a 81       	ldd	r25, Y+2	; 0x02
     8ba:	90 93 69 00 	sts	0x0069, r25
     8be:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     8c2:	0e 94 a3 06 	call	0xd46	; 0xd46 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     8c6:	8e 81       	ldd	r24, Y+6	; 0x06
     8c8:	82 30       	cpi	r24, 0x02	; 2
     8ca:	10 f0       	brcs	.+4      	; 0x8d0 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     8d0:	e9 81       	ldd	r30, Y+1	; 0x01
     8d2:	fa 81       	ldd	r31, Y+2	; 0x02
     8d4:	11 8e       	std	Z+25, r1	; 0x19
     8d6:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	8e 81       	ldd	r24, Y+6	; 0x06
     8de:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     8e0:	e9 81       	ldd	r30, Y+1	; 0x01
     8e2:	fa 81       	ldd	r31, Y+2	; 0x02
     8e4:	8f 81       	ldd	r24, Y+7	; 0x07
     8e6:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     8e8:	e9 81       	ldd	r30, Y+1	; 0x01
     8ea:	fa 81       	ldd	r31, Y+2	; 0x02
     8ec:	8c 81       	ldd	r24, Y+4	; 0x04
     8ee:	9d 81       	ldd	r25, Y+5	; 0x05
     8f0:	91 83       	std	Z+1, r25	; 0x01
     8f2:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     8f4:	89 81       	ldd	r24, Y+1	; 0x01
     8f6:	9a 81       	ldd	r25, Y+2	; 0x02
     8f8:	02 96       	adiw	r24, 0x02	; 2
     8fa:	0e 94 aa 07 	call	0xf54	; 0xf54 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     8fe:	89 81       	ldd	r24, Y+1	; 0x01
     900:	9a 81       	ldd	r25, Y+2	; 0x02
     902:	0c 96       	adiw	r24, 0x0c	; 12
     904:	0e 94 aa 07 	call	0xf54	; 0xf54 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     908:	e9 81       	ldd	r30, Y+1	; 0x01
     90a:	fa 81       	ldd	r31, Y+2	; 0x02
     90c:	89 81       	ldd	r24, Y+1	; 0x01
     90e:	9a 81       	ldd	r25, Y+2	; 0x02
     910:	91 87       	std	Z+9, r25	; 0x09
     912:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     914:	e9 81       	ldd	r30, Y+1	; 0x01
     916:	fa 81       	ldd	r31, Y+2	; 0x02
     918:	89 81       	ldd	r24, Y+1	; 0x01
     91a:	9a 81       	ldd	r25, Y+2	; 0x02
     91c:	93 8b       	std	Z+19, r25	; 0x13
     91e:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     920:	8e 81       	ldd	r24, Y+6	; 0x06
     922:	28 2f       	mov	r18, r24
     924:	30 e0       	ldi	r19, 0x00	; 0
     926:	89 e0       	ldi	r24, 0x09	; 9
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	82 1b       	sub	r24, r18
     92c:	93 0b       	sbc	r25, r19
     92e:	e9 81       	ldd	r30, Y+1	; 0x01
     930:	fa 81       	ldd	r31, Y+2	; 0x02
     932:	95 87       	std	Z+13, r25	; 0x0d
     934:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     936:	e9 81       	ldd	r30, Y+1	; 0x01
     938:	fa 81       	ldd	r31, Y+2	; 0x02
     93a:	96 89       	ldd	r25, Z+22	; 0x16
     93c:	80 91 6a 00 	lds	r24, 0x006A
     940:	89 17       	cp	r24, r25
     942:	28 f4       	brcc	.+10     	; 0x94e <xCoRoutineCreate+0xd6>
     944:	e9 81       	ldd	r30, Y+1	; 0x01
     946:	fa 81       	ldd	r31, Y+2	; 0x02
     948:	86 89       	ldd	r24, Z+22	; 0x16
     94a:	80 93 6a 00 	sts	0x006A, r24
     94e:	e9 81       	ldd	r30, Y+1	; 0x01
     950:	fa 81       	ldd	r31, Y+2	; 0x02
     952:	86 89       	ldd	r24, Z+22	; 0x16
     954:	28 2f       	mov	r18, r24
     956:	30 e0       	ldi	r19, 0x00	; 0
     958:	c9 01       	movw	r24, r18
     95a:	88 0f       	add	r24, r24
     95c:	99 1f       	adc	r25, r25
     95e:	88 0f       	add	r24, r24
     960:	99 1f       	adc	r25, r25
     962:	88 0f       	add	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	82 0f       	add	r24, r18
     968:	93 1f       	adc	r25, r19
     96a:	ac 01       	movw	r20, r24
     96c:	4f 58       	subi	r20, 0x8F	; 143
     96e:	5f 4f       	sbci	r21, 0xFF	; 255
     970:	89 81       	ldd	r24, Y+1	; 0x01
     972:	9a 81       	ldd	r25, Y+2	; 0x02
     974:	9c 01       	movw	r18, r24
     976:	2e 5f       	subi	r18, 0xFE	; 254
     978:	3f 4f       	sbci	r19, 0xFF	; 255
     97a:	ca 01       	movw	r24, r20
     97c:	b9 01       	movw	r22, r18
     97e:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>

		xReturn = pdPASS;
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	8b 83       	std	Y+3, r24	; 0x03
     986:	02 c0       	rjmp	.+4      	; 0x98c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     988:	8f ef       	ldi	r24, 0xFF	; 255
     98a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     98c:	8b 81       	ldd	r24, Y+3	; 0x03
}
     98e:	27 96       	adiw	r28, 0x07	; 7
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	f8 94       	cli
     994:	de bf       	out	0x3e, r29	; 62
     996:	0f be       	out	0x3f, r0	; 63
     998:	cd bf       	out	0x3d, r28	; 61
     99a:	cf 91       	pop	r28
     99c:	df 91       	pop	r29
     99e:	08 95       	ret

000009a0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     9a0:	df 93       	push	r29
     9a2:	cf 93       	push	r28
     9a4:	00 d0       	rcall	.+0      	; 0x9a6 <vCoRoutineAddToDelayedList+0x6>
     9a6:	00 d0       	rcall	.+0      	; 0x9a8 <vCoRoutineAddToDelayedList+0x8>
     9a8:	00 d0       	rcall	.+0      	; 0x9aa <vCoRoutineAddToDelayedList+0xa>
     9aa:	cd b7       	in	r28, 0x3d	; 61
     9ac:	de b7       	in	r29, 0x3e	; 62
     9ae:	9c 83       	std	Y+4, r25	; 0x04
     9b0:	8b 83       	std	Y+3, r24	; 0x03
     9b2:	7e 83       	std	Y+6, r23	; 0x06
     9b4:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     9b6:	20 91 6b 00 	lds	r18, 0x006B
     9ba:	30 91 6c 00 	lds	r19, 0x006C
     9be:	8b 81       	ldd	r24, Y+3	; 0x03
     9c0:	9c 81       	ldd	r25, Y+4	; 0x04
     9c2:	82 0f       	add	r24, r18
     9c4:	93 1f       	adc	r25, r19
     9c6:	9a 83       	std	Y+2, r25	; 0x02
     9c8:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     9ca:	80 91 68 00 	lds	r24, 0x0068
     9ce:	90 91 69 00 	lds	r25, 0x0069
     9d2:	02 96       	adiw	r24, 0x02	; 2
     9d4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     9d8:	e0 91 68 00 	lds	r30, 0x0068
     9dc:	f0 91 69 00 	lds	r31, 0x0069
     9e0:	89 81       	ldd	r24, Y+1	; 0x01
     9e2:	9a 81       	ldd	r25, Y+2	; 0x02
     9e4:	93 83       	std	Z+3, r25	; 0x03
     9e6:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     9e8:	20 91 6b 00 	lds	r18, 0x006B
     9ec:	30 91 6c 00 	lds	r19, 0x006C
     9f0:	89 81       	ldd	r24, Y+1	; 0x01
     9f2:	9a 81       	ldd	r25, Y+2	; 0x02
     9f4:	82 17       	cp	r24, r18
     9f6:	93 07       	cpc	r25, r19
     9f8:	70 f4       	brcc	.+28     	; 0xa16 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     9fa:	80 91 97 00 	lds	r24, 0x0097
     9fe:	90 91 98 00 	lds	r25, 0x0098
     a02:	20 91 68 00 	lds	r18, 0x0068
     a06:	30 91 69 00 	lds	r19, 0x0069
     a0a:	2e 5f       	subi	r18, 0xFE	; 254
     a0c:	3f 4f       	sbci	r19, 0xFF	; 255
     a0e:	b9 01       	movw	r22, r18
     a10:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>
     a14:	0d c0       	rjmp	.+26     	; 0xa30 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     a16:	80 91 95 00 	lds	r24, 0x0095
     a1a:	90 91 96 00 	lds	r25, 0x0096
     a1e:	20 91 68 00 	lds	r18, 0x0068
     a22:	30 91 69 00 	lds	r19, 0x0069
     a26:	2e 5f       	subi	r18, 0xFE	; 254
     a28:	3f 4f       	sbci	r19, 0xFF	; 255
     a2a:	b9 01       	movw	r22, r18
     a2c:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>
	}

	if( pxEventList )
     a30:	8d 81       	ldd	r24, Y+5	; 0x05
     a32:	9e 81       	ldd	r25, Y+6	; 0x06
     a34:	00 97       	sbiw	r24, 0x00	; 0
     a36:	61 f0       	breq	.+24     	; 0xa50 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     a38:	80 91 68 00 	lds	r24, 0x0068
     a3c:	90 91 69 00 	lds	r25, 0x0069
     a40:	9c 01       	movw	r18, r24
     a42:	24 5f       	subi	r18, 0xF4	; 244
     a44:	3f 4f       	sbci	r19, 0xFF	; 255
     a46:	8d 81       	ldd	r24, Y+5	; 0x05
     a48:	9e 81       	ldd	r25, Y+6	; 0x06
     a4a:	b9 01       	movw	r22, r18
     a4c:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>
	}
}
     a50:	26 96       	adiw	r28, 0x06	; 6
     a52:	0f b6       	in	r0, 0x3f	; 63
     a54:	f8 94       	cli
     a56:	de bf       	out	0x3e, r29	; 62
     a58:	0f be       	out	0x3f, r0	; 63
     a5a:	cd bf       	out	0x3d, r28	; 61
     a5c:	cf 91       	pop	r28
     a5e:	df 91       	pop	r29
     a60:	08 95       	ret

00000a62 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     a62:	df 93       	push	r29
     a64:	cf 93       	push	r28
     a66:	00 d0       	rcall	.+0      	; 0xa68 <prvCheckPendingReadyList+0x6>
     a68:	cd b7       	in	r28, 0x3d	; 61
     a6a:	de b7       	in	r29, 0x3e	; 62
     a6c:	3a c0       	rjmp	.+116    	; 0xae2 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     a6e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     a70:	e0 91 9e 00 	lds	r30, 0x009E
     a74:	f0 91 9f 00 	lds	r31, 0x009F
     a78:	86 81       	ldd	r24, Z+6	; 0x06
     a7a:	97 81       	ldd	r25, Z+7	; 0x07
     a7c:	9a 83       	std	Y+2, r25	; 0x02
     a7e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     a80:	89 81       	ldd	r24, Y+1	; 0x01
     a82:	9a 81       	ldd	r25, Y+2	; 0x02
     a84:	0c 96       	adiw	r24, 0x0c	; 12
     a86:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     a8a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     a8c:	89 81       	ldd	r24, Y+1	; 0x01
     a8e:	9a 81       	ldd	r25, Y+2	; 0x02
     a90:	02 96       	adiw	r24, 0x02	; 2
     a92:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     a96:	e9 81       	ldd	r30, Y+1	; 0x01
     a98:	fa 81       	ldd	r31, Y+2	; 0x02
     a9a:	96 89       	ldd	r25, Z+22	; 0x16
     a9c:	80 91 6a 00 	lds	r24, 0x006A
     aa0:	89 17       	cp	r24, r25
     aa2:	28 f4       	brcc	.+10     	; 0xaae <prvCheckPendingReadyList+0x4c>
     aa4:	e9 81       	ldd	r30, Y+1	; 0x01
     aa6:	fa 81       	ldd	r31, Y+2	; 0x02
     aa8:	86 89       	ldd	r24, Z+22	; 0x16
     aaa:	80 93 6a 00 	sts	0x006A, r24
     aae:	e9 81       	ldd	r30, Y+1	; 0x01
     ab0:	fa 81       	ldd	r31, Y+2	; 0x02
     ab2:	86 89       	ldd	r24, Z+22	; 0x16
     ab4:	28 2f       	mov	r18, r24
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	c9 01       	movw	r24, r18
     aba:	88 0f       	add	r24, r24
     abc:	99 1f       	adc	r25, r25
     abe:	88 0f       	add	r24, r24
     ac0:	99 1f       	adc	r25, r25
     ac2:	88 0f       	add	r24, r24
     ac4:	99 1f       	adc	r25, r25
     ac6:	82 0f       	add	r24, r18
     ac8:	93 1f       	adc	r25, r19
     aca:	ac 01       	movw	r20, r24
     acc:	4f 58       	subi	r20, 0x8F	; 143
     ace:	5f 4f       	sbci	r21, 0xFF	; 255
     ad0:	89 81       	ldd	r24, Y+1	; 0x01
     ad2:	9a 81       	ldd	r25, Y+2	; 0x02
     ad4:	9c 01       	movw	r18, r24
     ad6:	2e 5f       	subi	r18, 0xFE	; 254
     ad8:	3f 4f       	sbci	r19, 0xFF	; 255
     ada:	ca 01       	movw	r24, r20
     adc:	b9 01       	movw	r22, r18
     ade:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     ae2:	80 91 99 00 	lds	r24, 0x0099
     ae6:	88 23       	and	r24, r24
     ae8:	09 f0       	breq	.+2      	; 0xaec <prvCheckPendingReadyList+0x8a>
     aea:	c1 cf       	rjmp	.-126    	; 0xa6e <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     aec:	0f 90       	pop	r0
     aee:	0f 90       	pop	r0
     af0:	cf 91       	pop	r28
     af2:	df 91       	pop	r29
     af4:	08 95       	ret

00000af6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     af6:	df 93       	push	r29
     af8:	cf 93       	push	r28
     afa:	00 d0       	rcall	.+0      	; 0xafc <prvCheckDelayedList+0x6>
     afc:	00 d0       	rcall	.+0      	; 0xafe <prvCheckDelayedList+0x8>
     afe:	cd b7       	in	r28, 0x3d	; 61
     b00:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     b02:	0e 94 98 13 	call	0x2730	; 0x2730 <xTaskGetTickCount>
     b06:	20 91 6d 00 	lds	r18, 0x006D
     b0a:	30 91 6e 00 	lds	r19, 0x006E
     b0e:	82 1b       	sub	r24, r18
     b10:	93 0b       	sbc	r25, r19
     b12:	90 93 70 00 	sts	0x0070, r25
     b16:	80 93 6f 00 	sts	0x006F, r24
     b1a:	85 c0       	rjmp	.+266    	; 0xc26 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     b1c:	80 91 6b 00 	lds	r24, 0x006B
     b20:	90 91 6c 00 	lds	r25, 0x006C
     b24:	01 96       	adiw	r24, 0x01	; 1
     b26:	90 93 6c 00 	sts	0x006C, r25
     b2a:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     b2e:	80 91 6f 00 	lds	r24, 0x006F
     b32:	90 91 70 00 	lds	r25, 0x0070
     b36:	01 97       	sbiw	r24, 0x01	; 1
     b38:	90 93 70 00 	sts	0x0070, r25
     b3c:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     b40:	80 91 6b 00 	lds	r24, 0x006B
     b44:	90 91 6c 00 	lds	r25, 0x006C
     b48:	00 97       	sbiw	r24, 0x00	; 0
     b4a:	09 f0       	breq	.+2      	; 0xb4e <prvCheckDelayedList+0x58>
     b4c:	64 c0       	rjmp	.+200    	; 0xc16 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     b4e:	80 91 95 00 	lds	r24, 0x0095
     b52:	90 91 96 00 	lds	r25, 0x0096
     b56:	9a 83       	std	Y+2, r25	; 0x02
     b58:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     b5a:	80 91 97 00 	lds	r24, 0x0097
     b5e:	90 91 98 00 	lds	r25, 0x0098
     b62:	90 93 96 00 	sts	0x0096, r25
     b66:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     b6a:	89 81       	ldd	r24, Y+1	; 0x01
     b6c:	9a 81       	ldd	r25, Y+2	; 0x02
     b6e:	90 93 98 00 	sts	0x0098, r25
     b72:	80 93 97 00 	sts	0x0097, r24
     b76:	4f c0       	rjmp	.+158    	; 0xc16 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     b78:	e0 91 95 00 	lds	r30, 0x0095
     b7c:	f0 91 96 00 	lds	r31, 0x0096
     b80:	05 80       	ldd	r0, Z+5	; 0x05
     b82:	f6 81       	ldd	r31, Z+6	; 0x06
     b84:	e0 2d       	mov	r30, r0
     b86:	86 81       	ldd	r24, Z+6	; 0x06
     b88:	97 81       	ldd	r25, Z+7	; 0x07
     b8a:	9c 83       	std	Y+4, r25	; 0x04
     b8c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     b8e:	eb 81       	ldd	r30, Y+3	; 0x03
     b90:	fc 81       	ldd	r31, Y+4	; 0x04
     b92:	22 81       	ldd	r18, Z+2	; 0x02
     b94:	33 81       	ldd	r19, Z+3	; 0x03
     b96:	80 91 6b 00 	lds	r24, 0x006B
     b9a:	90 91 6c 00 	lds	r25, 0x006C
     b9e:	82 17       	cp	r24, r18
     ba0:	93 07       	cpc	r25, r19
     ba2:	08 f4       	brcc	.+2      	; 0xba6 <prvCheckDelayedList+0xb0>
     ba4:	40 c0       	rjmp	.+128    	; 0xc26 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     ba6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     ba8:	8b 81       	ldd	r24, Y+3	; 0x03
     baa:	9c 81       	ldd	r25, Y+4	; 0x04
     bac:	02 96       	adiw	r24, 0x02	; 2
     bae:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     bb2:	eb 81       	ldd	r30, Y+3	; 0x03
     bb4:	fc 81       	ldd	r31, Y+4	; 0x04
     bb6:	84 89       	ldd	r24, Z+20	; 0x14
     bb8:	95 89       	ldd	r25, Z+21	; 0x15
     bba:	00 97       	sbiw	r24, 0x00	; 0
     bbc:	29 f0       	breq	.+10     	; 0xbc8 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	9c 81       	ldd	r25, Y+4	; 0x04
     bc2:	0c 96       	adiw	r24, 0x0c	; 12
     bc4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     bc8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     bca:	eb 81       	ldd	r30, Y+3	; 0x03
     bcc:	fc 81       	ldd	r31, Y+4	; 0x04
     bce:	96 89       	ldd	r25, Z+22	; 0x16
     bd0:	80 91 6a 00 	lds	r24, 0x006A
     bd4:	89 17       	cp	r24, r25
     bd6:	28 f4       	brcc	.+10     	; 0xbe2 <prvCheckDelayedList+0xec>
     bd8:	eb 81       	ldd	r30, Y+3	; 0x03
     bda:	fc 81       	ldd	r31, Y+4	; 0x04
     bdc:	86 89       	ldd	r24, Z+22	; 0x16
     bde:	80 93 6a 00 	sts	0x006A, r24
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	86 89       	ldd	r24, Z+22	; 0x16
     be8:	28 2f       	mov	r18, r24
     bea:	30 e0       	ldi	r19, 0x00	; 0
     bec:	c9 01       	movw	r24, r18
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	88 0f       	add	r24, r24
     bf8:	99 1f       	adc	r25, r25
     bfa:	82 0f       	add	r24, r18
     bfc:	93 1f       	adc	r25, r19
     bfe:	ac 01       	movw	r20, r24
     c00:	4f 58       	subi	r20, 0x8F	; 143
     c02:	5f 4f       	sbci	r21, 0xFF	; 255
     c04:	8b 81       	ldd	r24, Y+3	; 0x03
     c06:	9c 81       	ldd	r25, Y+4	; 0x04
     c08:	9c 01       	movw	r18, r24
     c0a:	2e 5f       	subi	r18, 0xFE	; 254
     c0c:	3f 4f       	sbci	r19, 0xFF	; 255
     c0e:	ca 01       	movw	r24, r20
     c10:	b9 01       	movw	r22, r18
     c12:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     c16:	e0 91 95 00 	lds	r30, 0x0095
     c1a:	f0 91 96 00 	lds	r31, 0x0096
     c1e:	80 81       	ld	r24, Z
     c20:	88 23       	and	r24, r24
     c22:	09 f0       	breq	.+2      	; 0xc26 <prvCheckDelayedList+0x130>
     c24:	a9 cf       	rjmp	.-174    	; 0xb78 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     c26:	80 91 6f 00 	lds	r24, 0x006F
     c2a:	90 91 70 00 	lds	r25, 0x0070
     c2e:	00 97       	sbiw	r24, 0x00	; 0
     c30:	09 f0       	breq	.+2      	; 0xc34 <prvCheckDelayedList+0x13e>
     c32:	74 cf       	rjmp	.-280    	; 0xb1c <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     c34:	80 91 6b 00 	lds	r24, 0x006B
     c38:	90 91 6c 00 	lds	r25, 0x006C
     c3c:	90 93 6e 00 	sts	0x006E, r25
     c40:	80 93 6d 00 	sts	0x006D, r24
}
     c44:	0f 90       	pop	r0
     c46:	0f 90       	pop	r0
     c48:	0f 90       	pop	r0
     c4a:	0f 90       	pop	r0
     c4c:	cf 91       	pop	r28
     c4e:	df 91       	pop	r29
     c50:	08 95       	ret

00000c52 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     c52:	df 93       	push	r29
     c54:	cf 93       	push	r28
     c56:	00 d0       	rcall	.+0      	; 0xc58 <vCoRoutineSchedule+0x6>
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     c5c:	0e 94 31 05 	call	0xa62	; 0xa62 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     c60:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <prvCheckDelayedList>
     c64:	0a c0       	rjmp	.+20     	; 0xc7a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     c66:	80 91 6a 00 	lds	r24, 0x006A
     c6a:	88 23       	and	r24, r24
     c6c:	09 f4       	brne	.+2      	; 0xc70 <vCoRoutineSchedule+0x1e>
     c6e:	66 c0       	rjmp	.+204    	; 0xd3c <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     c70:	80 91 6a 00 	lds	r24, 0x006A
     c74:	81 50       	subi	r24, 0x01	; 1
     c76:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     c7a:	80 91 6a 00 	lds	r24, 0x006A
     c7e:	28 2f       	mov	r18, r24
     c80:	30 e0       	ldi	r19, 0x00	; 0
     c82:	c9 01       	movw	r24, r18
     c84:	88 0f       	add	r24, r24
     c86:	99 1f       	adc	r25, r25
     c88:	88 0f       	add	r24, r24
     c8a:	99 1f       	adc	r25, r25
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	fc 01       	movw	r30, r24
     c96:	ef 58       	subi	r30, 0x8F	; 143
     c98:	ff 4f       	sbci	r31, 0xFF	; 255
     c9a:	80 81       	ld	r24, Z
     c9c:	88 23       	and	r24, r24
     c9e:	19 f3       	breq	.-58     	; 0xc66 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     ca0:	80 91 6a 00 	lds	r24, 0x006A
     ca4:	28 2f       	mov	r18, r24
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	c9 01       	movw	r24, r18
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	88 0f       	add	r24, r24
     cb0:	99 1f       	adc	r25, r25
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	82 0f       	add	r24, r18
     cb8:	93 1f       	adc	r25, r19
     cba:	8f 58       	subi	r24, 0x8F	; 143
     cbc:	9f 4f       	sbci	r25, 0xFF	; 255
     cbe:	9a 83       	std	Y+2, r25	; 0x02
     cc0:	89 83       	std	Y+1, r24	; 0x01
     cc2:	e9 81       	ldd	r30, Y+1	; 0x01
     cc4:	fa 81       	ldd	r31, Y+2	; 0x02
     cc6:	01 80       	ldd	r0, Z+1	; 0x01
     cc8:	f2 81       	ldd	r31, Z+2	; 0x02
     cca:	e0 2d       	mov	r30, r0
     ccc:	82 81       	ldd	r24, Z+2	; 0x02
     cce:	93 81       	ldd	r25, Z+3	; 0x03
     cd0:	e9 81       	ldd	r30, Y+1	; 0x01
     cd2:	fa 81       	ldd	r31, Y+2	; 0x02
     cd4:	92 83       	std	Z+2, r25	; 0x02
     cd6:	81 83       	std	Z+1, r24	; 0x01
     cd8:	e9 81       	ldd	r30, Y+1	; 0x01
     cda:	fa 81       	ldd	r31, Y+2	; 0x02
     cdc:	21 81       	ldd	r18, Z+1	; 0x01
     cde:	32 81       	ldd	r19, Z+2	; 0x02
     ce0:	89 81       	ldd	r24, Y+1	; 0x01
     ce2:	9a 81       	ldd	r25, Y+2	; 0x02
     ce4:	03 96       	adiw	r24, 0x03	; 3
     ce6:	28 17       	cp	r18, r24
     ce8:	39 07       	cpc	r19, r25
     cea:	59 f4       	brne	.+22     	; 0xd02 <vCoRoutineSchedule+0xb0>
     cec:	e9 81       	ldd	r30, Y+1	; 0x01
     cee:	fa 81       	ldd	r31, Y+2	; 0x02
     cf0:	01 80       	ldd	r0, Z+1	; 0x01
     cf2:	f2 81       	ldd	r31, Z+2	; 0x02
     cf4:	e0 2d       	mov	r30, r0
     cf6:	82 81       	ldd	r24, Z+2	; 0x02
     cf8:	93 81       	ldd	r25, Z+3	; 0x03
     cfa:	e9 81       	ldd	r30, Y+1	; 0x01
     cfc:	fa 81       	ldd	r31, Y+2	; 0x02
     cfe:	92 83       	std	Z+2, r25	; 0x02
     d00:	81 83       	std	Z+1, r24	; 0x01
     d02:	e9 81       	ldd	r30, Y+1	; 0x01
     d04:	fa 81       	ldd	r31, Y+2	; 0x02
     d06:	01 80       	ldd	r0, Z+1	; 0x01
     d08:	f2 81       	ldd	r31, Z+2	; 0x02
     d0a:	e0 2d       	mov	r30, r0
     d0c:	86 81       	ldd	r24, Z+6	; 0x06
     d0e:	97 81       	ldd	r25, Z+7	; 0x07
     d10:	90 93 69 00 	sts	0x0069, r25
     d14:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     d18:	e0 91 68 00 	lds	r30, 0x0068
     d1c:	f0 91 69 00 	lds	r31, 0x0069
     d20:	40 81       	ld	r20, Z
     d22:	51 81       	ldd	r21, Z+1	; 0x01
     d24:	80 91 68 00 	lds	r24, 0x0068
     d28:	90 91 69 00 	lds	r25, 0x0069
     d2c:	e0 91 68 00 	lds	r30, 0x0068
     d30:	f0 91 69 00 	lds	r31, 0x0069
     d34:	27 89       	ldd	r18, Z+23	; 0x17
     d36:	62 2f       	mov	r22, r18
     d38:	fa 01       	movw	r30, r20
     d3a:	09 95       	icall

	return;
}
     d3c:	0f 90       	pop	r0
     d3e:	0f 90       	pop	r0
     d40:	cf 91       	pop	r28
     d42:	df 91       	pop	r29
     d44:	08 95       	ret

00000d46 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     d46:	df 93       	push	r29
     d48:	cf 93       	push	r28
     d4a:	0f 92       	push	r0
     d4c:	cd b7       	in	r28, 0x3d	; 61
     d4e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     d50:	19 82       	std	Y+1, r1	; 0x01
     d52:	13 c0       	rjmp	.+38     	; 0xd7a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     d54:	89 81       	ldd	r24, Y+1	; 0x01
     d56:	28 2f       	mov	r18, r24
     d58:	30 e0       	ldi	r19, 0x00	; 0
     d5a:	c9 01       	movw	r24, r18
     d5c:	88 0f       	add	r24, r24
     d5e:	99 1f       	adc	r25, r25
     d60:	88 0f       	add	r24, r24
     d62:	99 1f       	adc	r25, r25
     d64:	88 0f       	add	r24, r24
     d66:	99 1f       	adc	r25, r25
     d68:	82 0f       	add	r24, r18
     d6a:	93 1f       	adc	r25, r19
     d6c:	8f 58       	subi	r24, 0x8F	; 143
     d6e:	9f 4f       	sbci	r25, 0xFF	; 255
     d70:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     d74:	89 81       	ldd	r24, Y+1	; 0x01
     d76:	8f 5f       	subi	r24, 0xFF	; 255
     d78:	89 83       	std	Y+1, r24	; 0x01
     d7a:	89 81       	ldd	r24, Y+1	; 0x01
     d7c:	82 30       	cpi	r24, 0x02	; 2
     d7e:	50 f3       	brcs	.-44     	; 0xd54 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     d80:	83 e8       	ldi	r24, 0x83	; 131
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     d88:	8c e8       	ldi	r24, 0x8C	; 140
     d8a:	90 e0       	ldi	r25, 0x00	; 0
     d8c:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     d90:	89 e9       	ldi	r24, 0x99	; 153
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     d98:	83 e8       	ldi	r24, 0x83	; 131
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	90 93 96 00 	sts	0x0096, r25
     da0:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     da4:	8c e8       	ldi	r24, 0x8C	; 140
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	90 93 98 00 	sts	0x0098, r25
     dac:	80 93 97 00 	sts	0x0097, r24
}
     db0:	0f 90       	pop	r0
     db2:	cf 91       	pop	r28
     db4:	df 91       	pop	r29
     db6:	08 95       	ret

00000db8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     db8:	df 93       	push	r29
     dba:	cf 93       	push	r28
     dbc:	00 d0       	rcall	.+0      	; 0xdbe <xCoRoutineRemoveFromEventList+0x6>
     dbe:	00 d0       	rcall	.+0      	; 0xdc0 <xCoRoutineRemoveFromEventList+0x8>
     dc0:	0f 92       	push	r0
     dc2:	cd b7       	in	r28, 0x3d	; 61
     dc4:	de b7       	in	r29, 0x3e	; 62
     dc6:	9d 83       	std	Y+5, r25	; 0x05
     dc8:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     dca:	ec 81       	ldd	r30, Y+4	; 0x04
     dcc:	fd 81       	ldd	r31, Y+5	; 0x05
     dce:	05 80       	ldd	r0, Z+5	; 0x05
     dd0:	f6 81       	ldd	r31, Z+6	; 0x06
     dd2:	e0 2d       	mov	r30, r0
     dd4:	86 81       	ldd	r24, Z+6	; 0x06
     dd6:	97 81       	ldd	r25, Z+7	; 0x07
     dd8:	9b 83       	std	Y+3, r25	; 0x03
     dda:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     ddc:	8a 81       	ldd	r24, Y+2	; 0x02
     dde:	9b 81       	ldd	r25, Y+3	; 0x03
     de0:	0c 96       	adiw	r24, 0x0c	; 12
     de2:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     de6:	8a 81       	ldd	r24, Y+2	; 0x02
     de8:	9b 81       	ldd	r25, Y+3	; 0x03
     dea:	9c 01       	movw	r18, r24
     dec:	24 5f       	subi	r18, 0xF4	; 244
     dee:	3f 4f       	sbci	r19, 0xFF	; 255
     df0:	89 e9       	ldi	r24, 0x99	; 153
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	b9 01       	movw	r22, r18
     df6:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     dfa:	ea 81       	ldd	r30, Y+2	; 0x02
     dfc:	fb 81       	ldd	r31, Y+3	; 0x03
     dfe:	96 89       	ldd	r25, Z+22	; 0x16
     e00:	e0 91 68 00 	lds	r30, 0x0068
     e04:	f0 91 69 00 	lds	r31, 0x0069
     e08:	86 89       	ldd	r24, Z+22	; 0x16
     e0a:	98 17       	cp	r25, r24
     e0c:	18 f0       	brcs	.+6      	; 0xe14 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	89 83       	std	Y+1, r24	; 0x01
     e12:	01 c0       	rjmp	.+2      	; 0xe16 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     e14:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     e16:	89 81       	ldd	r24, Y+1	; 0x01
}
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	cf 91       	pop	r28
     e24:	df 91       	pop	r29
     e26:	08 95       	ret

00000e28 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e28:	df 93       	push	r29
     e2a:	cf 93       	push	r28
     e2c:	00 d0       	rcall	.+0      	; 0xe2e <pvPortMalloc+0x6>
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <pvPortMalloc+0x8>
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	9c 83       	std	Y+4, r25	; 0x04
     e36:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     e38:	1a 82       	std	Y+2, r1	; 0x02
     e3a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     e3c:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     e40:	80 91 a2 00 	lds	r24, 0x00A2
     e44:	90 91 a3 00 	lds	r25, 0x00A3
     e48:	2b 81       	ldd	r18, Y+3	; 0x03
     e4a:	3c 81       	ldd	r19, Y+4	; 0x04
     e4c:	82 0f       	add	r24, r18
     e4e:	93 1f       	adc	r25, r19
     e50:	24 e0       	ldi	r18, 0x04	; 4
     e52:	80 3b       	cpi	r24, 0xB0	; 176
     e54:	92 07       	cpc	r25, r18
     e56:	18 f5       	brcc	.+70     	; 0xe9e <pvPortMalloc+0x76>
     e58:	20 91 a2 00 	lds	r18, 0x00A2
     e5c:	30 91 a3 00 	lds	r19, 0x00A3
     e60:	8b 81       	ldd	r24, Y+3	; 0x03
     e62:	9c 81       	ldd	r25, Y+4	; 0x04
     e64:	28 0f       	add	r18, r24
     e66:	39 1f       	adc	r19, r25
     e68:	80 91 a2 00 	lds	r24, 0x00A2
     e6c:	90 91 a3 00 	lds	r25, 0x00A3
     e70:	82 17       	cp	r24, r18
     e72:	93 07       	cpc	r25, r19
     e74:	a0 f4       	brcc	.+40     	; 0xe9e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     e76:	80 91 a2 00 	lds	r24, 0x00A2
     e7a:	90 91 a3 00 	lds	r25, 0x00A3
     e7e:	8c 55       	subi	r24, 0x5C	; 92
     e80:	9f 4f       	sbci	r25, 0xFF	; 255
     e82:	9a 83       	std	Y+2, r25	; 0x02
     e84:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     e86:	20 91 a2 00 	lds	r18, 0x00A2
     e8a:	30 91 a3 00 	lds	r19, 0x00A3
     e8e:	8b 81       	ldd	r24, Y+3	; 0x03
     e90:	9c 81       	ldd	r25, Y+4	; 0x04
     e92:	82 0f       	add	r24, r18
     e94:	93 1f       	adc	r25, r19
     e96:	90 93 a3 00 	sts	0x00A3, r25
     e9a:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     e9e:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     ea2:	89 81       	ldd	r24, Y+1	; 0x01
     ea4:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	0f 90       	pop	r0
     eac:	0f 90       	pop	r0
     eae:	cf 91       	pop	r28
     eb0:	df 91       	pop	r29
     eb2:	08 95       	ret

00000eb4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     eb4:	df 93       	push	r29
     eb6:	cf 93       	push	r28
     eb8:	00 d0       	rcall	.+0      	; 0xeba <vPortFree+0x6>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	9a 83       	std	Y+2, r25	; 0x02
     ec0:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	cf 91       	pop	r28
     ec8:	df 91       	pop	r29
     eca:	08 95       	ret

00000ecc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     ecc:	df 93       	push	r29
     ece:	cf 93       	push	r28
     ed0:	cd b7       	in	r28, 0x3d	; 61
     ed2:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     ed4:	10 92 a3 00 	sts	0x00A3, r1
     ed8:	10 92 a2 00 	sts	0x00A2, r1
}
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	cd b7       	in	r28, 0x3d	; 61
     ee8:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     eea:	20 91 a2 00 	lds	r18, 0x00A2
     eee:	30 91 a3 00 	lds	r19, 0x00A3
     ef2:	80 eb       	ldi	r24, 0xB0	; 176
     ef4:	94 e0       	ldi	r25, 0x04	; 4
     ef6:	82 1b       	sub	r24, r18
     ef8:	93 0b       	sbc	r25, r19
}
     efa:	cf 91       	pop	r28
     efc:	df 91       	pop	r29
     efe:	08 95       	ret

00000f00 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     f00:	df 93       	push	r29
     f02:	cf 93       	push	r28
     f04:	00 d0       	rcall	.+0      	; 0xf06 <vListInitialise+0x6>
     f06:	cd b7       	in	r28, 0x3d	; 61
     f08:	de b7       	in	r29, 0x3e	; 62
     f0a:	9a 83       	std	Y+2, r25	; 0x02
     f0c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     f0e:	89 81       	ldd	r24, Y+1	; 0x01
     f10:	9a 81       	ldd	r25, Y+2	; 0x02
     f12:	03 96       	adiw	r24, 0x03	; 3
     f14:	e9 81       	ldd	r30, Y+1	; 0x01
     f16:	fa 81       	ldd	r31, Y+2	; 0x02
     f18:	92 83       	std	Z+2, r25	; 0x02
     f1a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     f1c:	e9 81       	ldd	r30, Y+1	; 0x01
     f1e:	fa 81       	ldd	r31, Y+2	; 0x02
     f20:	8f ef       	ldi	r24, 0xFF	; 255
     f22:	9f ef       	ldi	r25, 0xFF	; 255
     f24:	94 83       	std	Z+4, r25	; 0x04
     f26:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     f28:	89 81       	ldd	r24, Y+1	; 0x01
     f2a:	9a 81       	ldd	r25, Y+2	; 0x02
     f2c:	03 96       	adiw	r24, 0x03	; 3
     f2e:	e9 81       	ldd	r30, Y+1	; 0x01
     f30:	fa 81       	ldd	r31, Y+2	; 0x02
     f32:	96 83       	std	Z+6, r25	; 0x06
     f34:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	9a 81       	ldd	r25, Y+2	; 0x02
     f3a:	03 96       	adiw	r24, 0x03	; 3
     f3c:	e9 81       	ldd	r30, Y+1	; 0x01
     f3e:	fa 81       	ldd	r31, Y+2	; 0x02
     f40:	90 87       	std	Z+8, r25	; 0x08
     f42:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     f44:	e9 81       	ldd	r30, Y+1	; 0x01
     f46:	fa 81       	ldd	r31, Y+2	; 0x02
     f48:	10 82       	st	Z, r1
}
     f4a:	0f 90       	pop	r0
     f4c:	0f 90       	pop	r0
     f4e:	cf 91       	pop	r28
     f50:	df 91       	pop	r29
     f52:	08 95       	ret

00000f54 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     f54:	df 93       	push	r29
     f56:	cf 93       	push	r28
     f58:	00 d0       	rcall	.+0      	; 0xf5a <vListInitialiseItem+0x6>
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
     f5e:	9a 83       	std	Y+2, r25	; 0x02
     f60:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     f62:	e9 81       	ldd	r30, Y+1	; 0x01
     f64:	fa 81       	ldd	r31, Y+2	; 0x02
     f66:	11 86       	std	Z+9, r1	; 0x09
     f68:	10 86       	std	Z+8, r1	; 0x08
}
     f6a:	0f 90       	pop	r0
     f6c:	0f 90       	pop	r0
     f6e:	cf 91       	pop	r28
     f70:	df 91       	pop	r29
     f72:	08 95       	ret

00000f74 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     f74:	df 93       	push	r29
     f76:	cf 93       	push	r28
     f78:	00 d0       	rcall	.+0      	; 0xf7a <vListInsertEnd+0x6>
     f7a:	00 d0       	rcall	.+0      	; 0xf7c <vListInsertEnd+0x8>
     f7c:	00 d0       	rcall	.+0      	; 0xf7e <vListInsertEnd+0xa>
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
     f82:	9c 83       	std	Y+4, r25	; 0x04
     f84:	8b 83       	std	Y+3, r24	; 0x03
     f86:	7e 83       	std	Y+6, r23	; 0x06
     f88:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     f8a:	eb 81       	ldd	r30, Y+3	; 0x03
     f8c:	fc 81       	ldd	r31, Y+4	; 0x04
     f8e:	81 81       	ldd	r24, Z+1	; 0x01
     f90:	92 81       	ldd	r25, Z+2	; 0x02
     f92:	9a 83       	std	Y+2, r25	; 0x02
     f94:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     f96:	e9 81       	ldd	r30, Y+1	; 0x01
     f98:	fa 81       	ldd	r31, Y+2	; 0x02
     f9a:	82 81       	ldd	r24, Z+2	; 0x02
     f9c:	93 81       	ldd	r25, Z+3	; 0x03
     f9e:	ed 81       	ldd	r30, Y+5	; 0x05
     fa0:	fe 81       	ldd	r31, Y+6	; 0x06
     fa2:	93 83       	std	Z+3, r25	; 0x03
     fa4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     fa6:	eb 81       	ldd	r30, Y+3	; 0x03
     fa8:	fc 81       	ldd	r31, Y+4	; 0x04
     faa:	81 81       	ldd	r24, Z+1	; 0x01
     fac:	92 81       	ldd	r25, Z+2	; 0x02
     fae:	ed 81       	ldd	r30, Y+5	; 0x05
     fb0:	fe 81       	ldd	r31, Y+6	; 0x06
     fb2:	95 83       	std	Z+5, r25	; 0x05
     fb4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     fb6:	e9 81       	ldd	r30, Y+1	; 0x01
     fb8:	fa 81       	ldd	r31, Y+2	; 0x02
     fba:	02 80       	ldd	r0, Z+2	; 0x02
     fbc:	f3 81       	ldd	r31, Z+3	; 0x03
     fbe:	e0 2d       	mov	r30, r0
     fc0:	8d 81       	ldd	r24, Y+5	; 0x05
     fc2:	9e 81       	ldd	r25, Y+6	; 0x06
     fc4:	95 83       	std	Z+5, r25	; 0x05
     fc6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     fc8:	8d 81       	ldd	r24, Y+5	; 0x05
     fca:	9e 81       	ldd	r25, Y+6	; 0x06
     fcc:	e9 81       	ldd	r30, Y+1	; 0x01
     fce:	fa 81       	ldd	r31, Y+2	; 0x02
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     fd4:	8d 81       	ldd	r24, Y+5	; 0x05
     fd6:	9e 81       	ldd	r25, Y+6	; 0x06
     fd8:	eb 81       	ldd	r30, Y+3	; 0x03
     fda:	fc 81       	ldd	r31, Y+4	; 0x04
     fdc:	92 83       	std	Z+2, r25	; 0x02
     fde:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fe0:	ed 81       	ldd	r30, Y+5	; 0x05
     fe2:	fe 81       	ldd	r31, Y+6	; 0x06
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	9c 81       	ldd	r25, Y+4	; 0x04
     fe8:	91 87       	std	Z+9, r25	; 0x09
     fea:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     fec:	eb 81       	ldd	r30, Y+3	; 0x03
     fee:	fc 81       	ldd	r31, Y+4	; 0x04
     ff0:	80 81       	ld	r24, Z
     ff2:	8f 5f       	subi	r24, 0xFF	; 255
     ff4:	eb 81       	ldd	r30, Y+3	; 0x03
     ff6:	fc 81       	ldd	r31, Y+4	; 0x04
     ff8:	80 83       	st	Z, r24
}
     ffa:	26 96       	adiw	r28, 0x06	; 6
     ffc:	0f b6       	in	r0, 0x3f	; 63
     ffe:	f8 94       	cli
    1000:	de bf       	out	0x3e, r29	; 62
    1002:	0f be       	out	0x3f, r0	; 63
    1004:	cd bf       	out	0x3d, r28	; 61
    1006:	cf 91       	pop	r28
    1008:	df 91       	pop	r29
    100a:	08 95       	ret

0000100c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    100c:	df 93       	push	r29
    100e:	cf 93       	push	r28
    1010:	cd b7       	in	r28, 0x3d	; 61
    1012:	de b7       	in	r29, 0x3e	; 62
    1014:	28 97       	sbiw	r28, 0x08	; 8
    1016:	0f b6       	in	r0, 0x3f	; 63
    1018:	f8 94       	cli
    101a:	de bf       	out	0x3e, r29	; 62
    101c:	0f be       	out	0x3f, r0	; 63
    101e:	cd bf       	out	0x3d, r28	; 61
    1020:	9e 83       	std	Y+6, r25	; 0x06
    1022:	8d 83       	std	Y+5, r24	; 0x05
    1024:	78 87       	std	Y+8, r23	; 0x08
    1026:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1028:	ef 81       	ldd	r30, Y+7	; 0x07
    102a:	f8 85       	ldd	r31, Y+8	; 0x08
    102c:	80 81       	ld	r24, Z
    102e:	91 81       	ldd	r25, Z+1	; 0x01
    1030:	9a 83       	std	Y+2, r25	; 0x02
    1032:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1034:	89 81       	ldd	r24, Y+1	; 0x01
    1036:	9a 81       	ldd	r25, Y+2	; 0x02
    1038:	2f ef       	ldi	r18, 0xFF	; 255
    103a:	8f 3f       	cpi	r24, 0xFF	; 255
    103c:	92 07       	cpc	r25, r18
    103e:	39 f4       	brne	.+14     	; 0x104e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1040:	ed 81       	ldd	r30, Y+5	; 0x05
    1042:	fe 81       	ldd	r31, Y+6	; 0x06
    1044:	87 81       	ldd	r24, Z+7	; 0x07
    1046:	90 85       	ldd	r25, Z+8	; 0x08
    1048:	9c 83       	std	Y+4, r25	; 0x04
    104a:	8b 83       	std	Y+3, r24	; 0x03
    104c:	18 c0       	rjmp	.+48     	; 0x107e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    104e:	8d 81       	ldd	r24, Y+5	; 0x05
    1050:	9e 81       	ldd	r25, Y+6	; 0x06
    1052:	03 96       	adiw	r24, 0x03	; 3
    1054:	9c 83       	std	Y+4, r25	; 0x04
    1056:	8b 83       	std	Y+3, r24	; 0x03
    1058:	06 c0       	rjmp	.+12     	; 0x1066 <vListInsert+0x5a>
    105a:	eb 81       	ldd	r30, Y+3	; 0x03
    105c:	fc 81       	ldd	r31, Y+4	; 0x04
    105e:	82 81       	ldd	r24, Z+2	; 0x02
    1060:	93 81       	ldd	r25, Z+3	; 0x03
    1062:	9c 83       	std	Y+4, r25	; 0x04
    1064:	8b 83       	std	Y+3, r24	; 0x03
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	02 80       	ldd	r0, Z+2	; 0x02
    106c:	f3 81       	ldd	r31, Z+3	; 0x03
    106e:	e0 2d       	mov	r30, r0
    1070:	20 81       	ld	r18, Z
    1072:	31 81       	ldd	r19, Z+1	; 0x01
    1074:	89 81       	ldd	r24, Y+1	; 0x01
    1076:	9a 81       	ldd	r25, Y+2	; 0x02
    1078:	82 17       	cp	r24, r18
    107a:	93 07       	cpc	r25, r19
    107c:	70 f7       	brcc	.-36     	; 0x105a <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    107e:	eb 81       	ldd	r30, Y+3	; 0x03
    1080:	fc 81       	ldd	r31, Y+4	; 0x04
    1082:	82 81       	ldd	r24, Z+2	; 0x02
    1084:	93 81       	ldd	r25, Z+3	; 0x03
    1086:	ef 81       	ldd	r30, Y+7	; 0x07
    1088:	f8 85       	ldd	r31, Y+8	; 0x08
    108a:	93 83       	std	Z+3, r25	; 0x03
    108c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    108e:	ef 81       	ldd	r30, Y+7	; 0x07
    1090:	f8 85       	ldd	r31, Y+8	; 0x08
    1092:	02 80       	ldd	r0, Z+2	; 0x02
    1094:	f3 81       	ldd	r31, Z+3	; 0x03
    1096:	e0 2d       	mov	r30, r0
    1098:	8f 81       	ldd	r24, Y+7	; 0x07
    109a:	98 85       	ldd	r25, Y+8	; 0x08
    109c:	95 83       	std	Z+5, r25	; 0x05
    109e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    10a0:	ef 81       	ldd	r30, Y+7	; 0x07
    10a2:	f8 85       	ldd	r31, Y+8	; 0x08
    10a4:	8b 81       	ldd	r24, Y+3	; 0x03
    10a6:	9c 81       	ldd	r25, Y+4	; 0x04
    10a8:	95 83       	std	Z+5, r25	; 0x05
    10aa:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    10ac:	8f 81       	ldd	r24, Y+7	; 0x07
    10ae:	98 85       	ldd	r25, Y+8	; 0x08
    10b0:	eb 81       	ldd	r30, Y+3	; 0x03
    10b2:	fc 81       	ldd	r31, Y+4	; 0x04
    10b4:	93 83       	std	Z+3, r25	; 0x03
    10b6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10b8:	ef 81       	ldd	r30, Y+7	; 0x07
    10ba:	f8 85       	ldd	r31, Y+8	; 0x08
    10bc:	8d 81       	ldd	r24, Y+5	; 0x05
    10be:	9e 81       	ldd	r25, Y+6	; 0x06
    10c0:	91 87       	std	Z+9, r25	; 0x09
    10c2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    10c4:	ed 81       	ldd	r30, Y+5	; 0x05
    10c6:	fe 81       	ldd	r31, Y+6	; 0x06
    10c8:	80 81       	ld	r24, Z
    10ca:	8f 5f       	subi	r24, 0xFF	; 255
    10cc:	ed 81       	ldd	r30, Y+5	; 0x05
    10ce:	fe 81       	ldd	r31, Y+6	; 0x06
    10d0:	80 83       	st	Z, r24
}
    10d2:	28 96       	adiw	r28, 0x08	; 8
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	cd bf       	out	0x3d, r28	; 61
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <vListRemove+0x6>
    10ea:	00 d0       	rcall	.+0      	; 0x10ec <vListRemove+0x8>
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	9c 83       	std	Y+4, r25	; 0x04
    10f2:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10f4:	eb 81       	ldd	r30, Y+3	; 0x03
    10f6:	fc 81       	ldd	r31, Y+4	; 0x04
    10f8:	a2 81       	ldd	r26, Z+2	; 0x02
    10fa:	b3 81       	ldd	r27, Z+3	; 0x03
    10fc:	eb 81       	ldd	r30, Y+3	; 0x03
    10fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1100:	84 81       	ldd	r24, Z+4	; 0x04
    1102:	95 81       	ldd	r25, Z+5	; 0x05
    1104:	15 96       	adiw	r26, 0x05	; 5
    1106:	9c 93       	st	X, r25
    1108:	8e 93       	st	-X, r24
    110a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    110c:	eb 81       	ldd	r30, Y+3	; 0x03
    110e:	fc 81       	ldd	r31, Y+4	; 0x04
    1110:	a4 81       	ldd	r26, Z+4	; 0x04
    1112:	b5 81       	ldd	r27, Z+5	; 0x05
    1114:	eb 81       	ldd	r30, Y+3	; 0x03
    1116:	fc 81       	ldd	r31, Y+4	; 0x04
    1118:	82 81       	ldd	r24, Z+2	; 0x02
    111a:	93 81       	ldd	r25, Z+3	; 0x03
    111c:	13 96       	adiw	r26, 0x03	; 3
    111e:	9c 93       	st	X, r25
    1120:	8e 93       	st	-X, r24
    1122:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1124:	eb 81       	ldd	r30, Y+3	; 0x03
    1126:	fc 81       	ldd	r31, Y+4	; 0x04
    1128:	80 85       	ldd	r24, Z+8	; 0x08
    112a:	91 85       	ldd	r25, Z+9	; 0x09
    112c:	9a 83       	std	Y+2, r25	; 0x02
    112e:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1130:	e9 81       	ldd	r30, Y+1	; 0x01
    1132:	fa 81       	ldd	r31, Y+2	; 0x02
    1134:	21 81       	ldd	r18, Z+1	; 0x01
    1136:	32 81       	ldd	r19, Z+2	; 0x02
    1138:	8b 81       	ldd	r24, Y+3	; 0x03
    113a:	9c 81       	ldd	r25, Y+4	; 0x04
    113c:	28 17       	cp	r18, r24
    113e:	39 07       	cpc	r19, r25
    1140:	41 f4       	brne	.+16     	; 0x1152 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1142:	eb 81       	ldd	r30, Y+3	; 0x03
    1144:	fc 81       	ldd	r31, Y+4	; 0x04
    1146:	84 81       	ldd	r24, Z+4	; 0x04
    1148:	95 81       	ldd	r25, Z+5	; 0x05
    114a:	e9 81       	ldd	r30, Y+1	; 0x01
    114c:	fa 81       	ldd	r31, Y+2	; 0x02
    114e:	92 83       	std	Z+2, r25	; 0x02
    1150:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1152:	eb 81       	ldd	r30, Y+3	; 0x03
    1154:	fc 81       	ldd	r31, Y+4	; 0x04
    1156:	11 86       	std	Z+9, r1	; 0x09
    1158:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    115a:	e9 81       	ldd	r30, Y+1	; 0x01
    115c:	fa 81       	ldd	r31, Y+2	; 0x02
    115e:	80 81       	ld	r24, Z
    1160:	81 50       	subi	r24, 0x01	; 1
    1162:	e9 81       	ldd	r30, Y+1	; 0x01
    1164:	fa 81       	ldd	r31, Y+2	; 0x02
    1166:	80 83       	st	Z, r24
}
    1168:	0f 90       	pop	r0
    116a:	0f 90       	pop	r0
    116c:	0f 90       	pop	r0
    116e:	0f 90       	pop	r0
    1170:	cf 91       	pop	r28
    1172:	df 91       	pop	r29
    1174:	08 95       	ret

00001176 <Led1>:
#include "avr/delay.h"
#include "semphr.h"


void Led1(void* ptr)
{
    1176:	df 93       	push	r29
    1178:	cf 93       	push	r28
    117a:	00 d0       	rcall	.+0      	; 0x117c <Led1+0x6>
    117c:	cd b7       	in	r28, 0x3d	; 61
    117e:	de b7       	in	r29, 0x3e	; 62
    1180:	9a 83       	std	Y+2, r25	; 0x02
    1182:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{

	DIO_VidTogglePin(0,PIN0);
    1184:	80 e0       	ldi	r24, 0x00	; 0
    1186:	60 e0       	ldi	r22, 0x00	; 0
    1188:	0e 94 7d 03 	call	0x6fa	; 0x6fa <DIO_VidTogglePin>
	vTaskDelay(4000);
    118c:	80 ea       	ldi	r24, 0xA0	; 160
    118e:	9f e0       	ldi	r25, 0x0F	; 15
    1190:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskDelay>
    1194:	f7 cf       	rjmp	.-18     	; 0x1184 <Led1+0xe>

00001196 <Led2>:
	}
}
void Led2(void* ptr)
{
    1196:	df 93       	push	r29
    1198:	cf 93       	push	r28
    119a:	00 d0       	rcall	.+0      	; 0x119c <Led2+0x6>
    119c:	cd b7       	in	r28, 0x3d	; 61
    119e:	de b7       	in	r29, 0x3e	; 62
    11a0:	9a 83       	std	Y+2, r25	; 0x02
    11a2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
	DIO_VidTogglePin(0,PIN1);
    11a4:	80 e0       	ldi	r24, 0x00	; 0
    11a6:	61 e0       	ldi	r22, 0x01	; 1
    11a8:	0e 94 7d 03 	call	0x6fa	; 0x6fa <DIO_VidTogglePin>
	vTaskDelay(3000);
    11ac:	88 eb       	ldi	r24, 0xB8	; 184
    11ae:	9b e0       	ldi	r25, 0x0B	; 11
    11b0:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskDelay>
    11b4:	f7 cf       	rjmp	.-18     	; 0x11a4 <Led2+0xe>

000011b6 <Led3>:
	}

}
void Led3(void* ptr)
{
    11b6:	df 93       	push	r29
    11b8:	cf 93       	push	r28
    11ba:	00 d0       	rcall	.+0      	; 0x11bc <Led3+0x6>
    11bc:	cd b7       	in	r28, 0x3d	; 61
    11be:	de b7       	in	r29, 0x3e	; 62
    11c0:	9a 83       	std	Y+2, r25	; 0x02
    11c2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
	DIO_VidTogglePin(0,PIN2);
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	62 e0       	ldi	r22, 0x02	; 2
    11c8:	0e 94 7d 03 	call	0x6fa	; 0x6fa <DIO_VidTogglePin>
	vTaskDelay(2000);
    11cc:	80 ed       	ldi	r24, 0xD0	; 208
    11ce:	97 e0       	ldi	r25, 0x07	; 7
    11d0:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskDelay>
    11d4:	f7 cf       	rjmp	.-18     	; 0x11c4 <Led3+0xe>

000011d6 <Led4>:
	}
}
void Led4(void* ptr)
{
    11d6:	df 93       	push	r29
    11d8:	cf 93       	push	r28
    11da:	00 d0       	rcall	.+0      	; 0x11dc <Led4+0x6>
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
    11e0:	9a 83       	std	Y+2, r25	; 0x02
    11e2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
	DIO_VidTogglePin(0,PIN3);
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	63 e0       	ldi	r22, 0x03	; 3
    11e8:	0e 94 7d 03 	call	0x6fa	; 0x6fa <DIO_VidTogglePin>
	vTaskDelay(1000);
    11ec:	88 ee       	ldi	r24, 0xE8	; 232
    11ee:	93 e0       	ldi	r25, 0x03	; 3
    11f0:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskDelay>
    11f4:	f7 cf       	rjmp	.-18     	; 0x11e4 <Led4+0xe>

000011f6 <main>:




int main()
{
    11f6:	af 92       	push	r10
    11f8:	bf 92       	push	r11
    11fa:	cf 92       	push	r12
    11fc:	df 92       	push	r13
    11fe:	ef 92       	push	r14
    1200:	ff 92       	push	r15
    1202:	0f 93       	push	r16
    1204:	df 93       	push	r29
    1206:	cf 93       	push	r28
    1208:	cd b7       	in	r28, 0x3d	; 61
    120a:	de b7       	in	r29, 0x3e	; 62
    120c:	28 97       	sbiw	r28, 0x08	; 8
    120e:	0f b6       	in	r0, 0x3f	; 63
    1210:	f8 94       	cli
    1212:	de bf       	out	0x3e, r29	; 62
    1214:	0f be       	out	0x3f, r0	; 63
    1216:	cd bf       	out	0x3d, r28	; 61
	xTaskHandle * LED1Handle;
	xTaskHandle * LED2Handle;
	xTaskHandle * LED3Handle;
	xTaskHandle * LED4Handle;

	DIO_VidSetPortDirection(0,OUTPUT);
    1218:	80 e0       	ldi	r24, 0x00	; 0
    121a:	61 e0       	ldi	r22, 0x01	; 1
    121c:	0e 94 c3 02 	call	0x586	; 0x586 <DIO_VidSetPortDirection>
	DIO_VidSetPortValue(0,LOW);
    1220:	80 e0       	ldi	r24, 0x00	; 0
    1222:	60 e0       	ldi	r22, 0x00	; 0
    1224:	0e 94 3c 03 	call	0x678	; 0x678 <DIO_VidSetPortValue>

		if(xTaskCreate(Led1,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL)==pdPASS)
    1228:	8b eb       	ldi	r24, 0xBB	; 187
    122a:	98 e0       	ldi	r25, 0x08	; 8
    122c:	60 e0       	ldi	r22, 0x00	; 0
    122e:	70 e0       	ldi	r23, 0x00	; 0
    1230:	4b e9       	ldi	r20, 0x9B	; 155
    1232:	50 e0       	ldi	r21, 0x00	; 0
    1234:	20 e0       	ldi	r18, 0x00	; 0
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	01 e0       	ldi	r16, 0x01	; 1
    123a:	ee 24       	eor	r14, r14
    123c:	ff 24       	eor	r15, r15
    123e:	cc 24       	eor	r12, r12
    1240:	dd 24       	eor	r13, r13
    1242:	aa 24       	eor	r10, r10
    1244:	bb 24       	eor	r11, r11
    1246:	0e 94 c6 10 	call	0x218c	; 0x218c <xTaskGenericCreate>
    124a:	81 30       	cpi	r24, 0x01	; 1
    124c:	29 f4       	brne	.+10     	; 0x1258 <main+0x62>
		{
				DIO_VidSetPinValue(0,PIN6,HIGH);
    124e:	80 e0       	ldi	r24, 0x00	; 0
    1250:	66 e0       	ldi	r22, 0x06	; 6
    1252:	41 e0       	ldi	r20, 0x01	; 1
    1254:	0e 94 49 01 	call	0x292	; 0x292 <DIO_VidSetPinValue>
		}
		xTaskCreate(Led2,NULL,configMINIMAL_STACK_SIZE,NULL,2,NULL);
    1258:	8b ec       	ldi	r24, 0xCB	; 203
    125a:	98 e0       	ldi	r25, 0x08	; 8
    125c:	60 e0       	ldi	r22, 0x00	; 0
    125e:	70 e0       	ldi	r23, 0x00	; 0
    1260:	4b e9       	ldi	r20, 0x9B	; 155
    1262:	50 e0       	ldi	r21, 0x00	; 0
    1264:	20 e0       	ldi	r18, 0x00	; 0
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	02 e0       	ldi	r16, 0x02	; 2
    126a:	ee 24       	eor	r14, r14
    126c:	ff 24       	eor	r15, r15
    126e:	cc 24       	eor	r12, r12
    1270:	dd 24       	eor	r13, r13
    1272:	aa 24       	eor	r10, r10
    1274:	bb 24       	eor	r11, r11
    1276:	0e 94 c6 10 	call	0x218c	; 0x218c <xTaskGenericCreate>
		xTaskCreate(Led3,NULL,configMINIMAL_STACK_SIZE,NULL,3,NULL);
    127a:	8b ed       	ldi	r24, 0xDB	; 219
    127c:	98 e0       	ldi	r25, 0x08	; 8
    127e:	60 e0       	ldi	r22, 0x00	; 0
    1280:	70 e0       	ldi	r23, 0x00	; 0
    1282:	4b e9       	ldi	r20, 0x9B	; 155
    1284:	50 e0       	ldi	r21, 0x00	; 0
    1286:	20 e0       	ldi	r18, 0x00	; 0
    1288:	30 e0       	ldi	r19, 0x00	; 0
    128a:	03 e0       	ldi	r16, 0x03	; 3
    128c:	ee 24       	eor	r14, r14
    128e:	ff 24       	eor	r15, r15
    1290:	cc 24       	eor	r12, r12
    1292:	dd 24       	eor	r13, r13
    1294:	aa 24       	eor	r10, r10
    1296:	bb 24       	eor	r11, r11
    1298:	0e 94 c6 10 	call	0x218c	; 0x218c <xTaskGenericCreate>
		xTaskCreate(Led4,NULL,configMINIMAL_STACK_SIZE,NULL,4,NULL);
    129c:	8b ee       	ldi	r24, 0xEB	; 235
    129e:	98 e0       	ldi	r25, 0x08	; 8
    12a0:	60 e0       	ldi	r22, 0x00	; 0
    12a2:	70 e0       	ldi	r23, 0x00	; 0
    12a4:	4b e9       	ldi	r20, 0x9B	; 155
    12a6:	50 e0       	ldi	r21, 0x00	; 0
    12a8:	20 e0       	ldi	r18, 0x00	; 0
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	04 e0       	ldi	r16, 0x04	; 4
    12ae:	ee 24       	eor	r14, r14
    12b0:	ff 24       	eor	r15, r15
    12b2:	cc 24       	eor	r12, r12
    12b4:	dd 24       	eor	r13, r13
    12b6:	aa 24       	eor	r10, r10
    12b8:	bb 24       	eor	r11, r11
    12ba:	0e 94 c6 10 	call	0x218c	; 0x218c <xTaskGenericCreate>
//	xTaskCreate(Led4,NULL,configMINIMAL_STACK_SIZE,NULL,0,NULL);
//	xTaskCreate(Led1,NULL,200,NULL,1,NULL);
//	xTaskCreate(Led2,NULL,200,NULL,2,NULL);
//	xTaskCreate(Led3,NULL,200,NULL,3,NULL);

	vTaskStartScheduler();
    12be:	0e 94 bf 12 	call	0x257e	; 0x257e <vTaskStartScheduler>
    12c2:	80 e0       	ldi	r24, 0x00	; 0
    12c4:	90 e0       	ldi	r25, 0x00	; 0


}
    12c6:	28 96       	adiw	r28, 0x08	; 8
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	de bf       	out	0x3e, r29	; 62
    12ce:	0f be       	out	0x3f, r0	; 63
    12d0:	cd bf       	out	0x3d, r28	; 61
    12d2:	cf 91       	pop	r28
    12d4:	df 91       	pop	r29
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	af 90       	pop	r10
    12e4:	08 95       	ret

000012e6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    12e6:	df 93       	push	r29
    12e8:	cf 93       	push	r28
    12ea:	cd b7       	in	r28, 0x3d	; 61
    12ec:	de b7       	in	r29, 0x3e	; 62
    12ee:	28 97       	sbiw	r28, 0x08	; 8
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	f8 94       	cli
    12f4:	de bf       	out	0x3e, r29	; 62
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	cd bf       	out	0x3d, r28	; 61
    12fa:	9c 83       	std	Y+4, r25	; 0x04
    12fc:	8b 83       	std	Y+3, r24	; 0x03
    12fe:	7e 83       	std	Y+6, r23	; 0x06
    1300:	6d 83       	std	Y+5, r22	; 0x05
    1302:	58 87       	std	Y+8, r21	; 0x08
    1304:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1306:	eb 81       	ldd	r30, Y+3	; 0x03
    1308:	fc 81       	ldd	r31, Y+4	; 0x04
    130a:	81 e1       	ldi	r24, 0x11	; 17
    130c:	80 83       	st	Z, r24
	pxTopOfStack--;
    130e:	8b 81       	ldd	r24, Y+3	; 0x03
    1310:	9c 81       	ldd	r25, Y+4	; 0x04
    1312:	01 97       	sbiw	r24, 0x01	; 1
    1314:	9c 83       	std	Y+4, r25	; 0x04
    1316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1318:	eb 81       	ldd	r30, Y+3	; 0x03
    131a:	fc 81       	ldd	r31, Y+4	; 0x04
    131c:	82 e2       	ldi	r24, 0x22	; 34
    131e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1320:	8b 81       	ldd	r24, Y+3	; 0x03
    1322:	9c 81       	ldd	r25, Y+4	; 0x04
    1324:	01 97       	sbiw	r24, 0x01	; 1
    1326:	9c 83       	std	Y+4, r25	; 0x04
    1328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    132a:	eb 81       	ldd	r30, Y+3	; 0x03
    132c:	fc 81       	ldd	r31, Y+4	; 0x04
    132e:	83 e3       	ldi	r24, 0x33	; 51
    1330:	80 83       	st	Z, r24
	pxTopOfStack--;
    1332:	8b 81       	ldd	r24, Y+3	; 0x03
    1334:	9c 81       	ldd	r25, Y+4	; 0x04
    1336:	01 97       	sbiw	r24, 0x01	; 1
    1338:	9c 83       	std	Y+4, r25	; 0x04
    133a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    133c:	8d 81       	ldd	r24, Y+5	; 0x05
    133e:	9e 81       	ldd	r25, Y+6	; 0x06
    1340:	9a 83       	std	Y+2, r25	; 0x02
    1342:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1344:	89 81       	ldd	r24, Y+1	; 0x01
    1346:	eb 81       	ldd	r30, Y+3	; 0x03
    1348:	fc 81       	ldd	r31, Y+4	; 0x04
    134a:	80 83       	st	Z, r24
	pxTopOfStack--;
    134c:	8b 81       	ldd	r24, Y+3	; 0x03
    134e:	9c 81       	ldd	r25, Y+4	; 0x04
    1350:	01 97       	sbiw	r24, 0x01	; 1
    1352:	9c 83       	std	Y+4, r25	; 0x04
    1354:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1356:	89 81       	ldd	r24, Y+1	; 0x01
    1358:	9a 81       	ldd	r25, Y+2	; 0x02
    135a:	89 2f       	mov	r24, r25
    135c:	99 27       	eor	r25, r25
    135e:	9a 83       	std	Y+2, r25	; 0x02
    1360:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1362:	89 81       	ldd	r24, Y+1	; 0x01
    1364:	eb 81       	ldd	r30, Y+3	; 0x03
    1366:	fc 81       	ldd	r31, Y+4	; 0x04
    1368:	80 83       	st	Z, r24
	pxTopOfStack--;
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	9c 81       	ldd	r25, Y+4	; 0x04
    136e:	01 97       	sbiw	r24, 0x01	; 1
    1370:	9c 83       	std	Y+4, r25	; 0x04
    1372:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	10 82       	st	Z, r1
	pxTopOfStack--;
    137a:	8b 81       	ldd	r24, Y+3	; 0x03
    137c:	9c 81       	ldd	r25, Y+4	; 0x04
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	9c 83       	std	Y+4, r25	; 0x04
    1382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1384:	eb 81       	ldd	r30, Y+3	; 0x03
    1386:	fc 81       	ldd	r31, Y+4	; 0x04
    1388:	80 e8       	ldi	r24, 0x80	; 128
    138a:	80 83       	st	Z, r24
	pxTopOfStack--;
    138c:	8b 81       	ldd	r24, Y+3	; 0x03
    138e:	9c 81       	ldd	r25, Y+4	; 0x04
    1390:	01 97       	sbiw	r24, 0x01	; 1
    1392:	9c 83       	std	Y+4, r25	; 0x04
    1394:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1396:	eb 81       	ldd	r30, Y+3	; 0x03
    1398:	fc 81       	ldd	r31, Y+4	; 0x04
    139a:	10 82       	st	Z, r1
	pxTopOfStack--;
    139c:	8b 81       	ldd	r24, Y+3	; 0x03
    139e:	9c 81       	ldd	r25, Y+4	; 0x04
    13a0:	01 97       	sbiw	r24, 0x01	; 1
    13a2:	9c 83       	std	Y+4, r25	; 0x04
    13a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    13a6:	eb 81       	ldd	r30, Y+3	; 0x03
    13a8:	fc 81       	ldd	r31, Y+4	; 0x04
    13aa:	82 e0       	ldi	r24, 0x02	; 2
    13ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	9c 81       	ldd	r25, Y+4	; 0x04
    13b2:	01 97       	sbiw	r24, 0x01	; 1
    13b4:	9c 83       	std	Y+4, r25	; 0x04
    13b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    13b8:	eb 81       	ldd	r30, Y+3	; 0x03
    13ba:	fc 81       	ldd	r31, Y+4	; 0x04
    13bc:	83 e0       	ldi	r24, 0x03	; 3
    13be:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c0:	8b 81       	ldd	r24, Y+3	; 0x03
    13c2:	9c 81       	ldd	r25, Y+4	; 0x04
    13c4:	01 97       	sbiw	r24, 0x01	; 1
    13c6:	9c 83       	std	Y+4, r25	; 0x04
    13c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    13ca:	eb 81       	ldd	r30, Y+3	; 0x03
    13cc:	fc 81       	ldd	r31, Y+4	; 0x04
    13ce:	84 e0       	ldi	r24, 0x04	; 4
    13d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d2:	8b 81       	ldd	r24, Y+3	; 0x03
    13d4:	9c 81       	ldd	r25, Y+4	; 0x04
    13d6:	01 97       	sbiw	r24, 0x01	; 1
    13d8:	9c 83       	std	Y+4, r25	; 0x04
    13da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    13dc:	eb 81       	ldd	r30, Y+3	; 0x03
    13de:	fc 81       	ldd	r31, Y+4	; 0x04
    13e0:	85 e0       	ldi	r24, 0x05	; 5
    13e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e4:	8b 81       	ldd	r24, Y+3	; 0x03
    13e6:	9c 81       	ldd	r25, Y+4	; 0x04
    13e8:	01 97       	sbiw	r24, 0x01	; 1
    13ea:	9c 83       	std	Y+4, r25	; 0x04
    13ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    13ee:	eb 81       	ldd	r30, Y+3	; 0x03
    13f0:	fc 81       	ldd	r31, Y+4	; 0x04
    13f2:	86 e0       	ldi	r24, 0x06	; 6
    13f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f6:	8b 81       	ldd	r24, Y+3	; 0x03
    13f8:	9c 81       	ldd	r25, Y+4	; 0x04
    13fa:	01 97       	sbiw	r24, 0x01	; 1
    13fc:	9c 83       	std	Y+4, r25	; 0x04
    13fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1400:	eb 81       	ldd	r30, Y+3	; 0x03
    1402:	fc 81       	ldd	r31, Y+4	; 0x04
    1404:	87 e0       	ldi	r24, 0x07	; 7
    1406:	80 83       	st	Z, r24
	pxTopOfStack--;
    1408:	8b 81       	ldd	r24, Y+3	; 0x03
    140a:	9c 81       	ldd	r25, Y+4	; 0x04
    140c:	01 97       	sbiw	r24, 0x01	; 1
    140e:	9c 83       	std	Y+4, r25	; 0x04
    1410:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1412:	eb 81       	ldd	r30, Y+3	; 0x03
    1414:	fc 81       	ldd	r31, Y+4	; 0x04
    1416:	88 e0       	ldi	r24, 0x08	; 8
    1418:	80 83       	st	Z, r24
	pxTopOfStack--;
    141a:	8b 81       	ldd	r24, Y+3	; 0x03
    141c:	9c 81       	ldd	r25, Y+4	; 0x04
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	9c 83       	std	Y+4, r25	; 0x04
    1422:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1424:	eb 81       	ldd	r30, Y+3	; 0x03
    1426:	fc 81       	ldd	r31, Y+4	; 0x04
    1428:	89 e0       	ldi	r24, 0x09	; 9
    142a:	80 83       	st	Z, r24
	pxTopOfStack--;
    142c:	8b 81       	ldd	r24, Y+3	; 0x03
    142e:	9c 81       	ldd	r25, Y+4	; 0x04
    1430:	01 97       	sbiw	r24, 0x01	; 1
    1432:	9c 83       	std	Y+4, r25	; 0x04
    1434:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1436:	eb 81       	ldd	r30, Y+3	; 0x03
    1438:	fc 81       	ldd	r31, Y+4	; 0x04
    143a:	80 e1       	ldi	r24, 0x10	; 16
    143c:	80 83       	st	Z, r24
	pxTopOfStack--;
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	9c 81       	ldd	r25, Y+4	; 0x04
    1442:	01 97       	sbiw	r24, 0x01	; 1
    1444:	9c 83       	std	Y+4, r25	; 0x04
    1446:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1448:	eb 81       	ldd	r30, Y+3	; 0x03
    144a:	fc 81       	ldd	r31, Y+4	; 0x04
    144c:	81 e1       	ldi	r24, 0x11	; 17
    144e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1450:	8b 81       	ldd	r24, Y+3	; 0x03
    1452:	9c 81       	ldd	r25, Y+4	; 0x04
    1454:	01 97       	sbiw	r24, 0x01	; 1
    1456:	9c 83       	std	Y+4, r25	; 0x04
    1458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    145a:	eb 81       	ldd	r30, Y+3	; 0x03
    145c:	fc 81       	ldd	r31, Y+4	; 0x04
    145e:	82 e1       	ldi	r24, 0x12	; 18
    1460:	80 83       	st	Z, r24
	pxTopOfStack--;
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	01 97       	sbiw	r24, 0x01	; 1
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    146c:	eb 81       	ldd	r30, Y+3	; 0x03
    146e:	fc 81       	ldd	r31, Y+4	; 0x04
    1470:	83 e1       	ldi	r24, 0x13	; 19
    1472:	80 83       	st	Z, r24
	pxTopOfStack--;
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	9c 83       	std	Y+4, r25	; 0x04
    147c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    147e:	eb 81       	ldd	r30, Y+3	; 0x03
    1480:	fc 81       	ldd	r31, Y+4	; 0x04
    1482:	84 e1       	ldi	r24, 0x14	; 20
    1484:	80 83       	st	Z, r24
	pxTopOfStack--;
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	01 97       	sbiw	r24, 0x01	; 1
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	85 e1       	ldi	r24, 0x15	; 21
    1496:	80 83       	st	Z, r24
	pxTopOfStack--;
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
    149c:	01 97       	sbiw	r24, 0x01	; 1
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    14a2:	eb 81       	ldd	r30, Y+3	; 0x03
    14a4:	fc 81       	ldd	r31, Y+4	; 0x04
    14a6:	86 e1       	ldi	r24, 0x16	; 22
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	87 e1       	ldi	r24, 0x17	; 23
    14ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	9c 81       	ldd	r25, Y+4	; 0x04
    14c0:	01 97       	sbiw	r24, 0x01	; 1
    14c2:	9c 83       	std	Y+4, r25	; 0x04
    14c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	88 e1       	ldi	r24, 0x18	; 24
    14cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ce:	8b 81       	ldd	r24, Y+3	; 0x03
    14d0:	9c 81       	ldd	r25, Y+4	; 0x04
    14d2:	01 97       	sbiw	r24, 0x01	; 1
    14d4:	9c 83       	std	Y+4, r25	; 0x04
    14d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	89 e1       	ldi	r24, 0x19	; 25
    14de:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e0:	8b 81       	ldd	r24, Y+3	; 0x03
    14e2:	9c 81       	ldd	r25, Y+4	; 0x04
    14e4:	01 97       	sbiw	r24, 0x01	; 1
    14e6:	9c 83       	std	Y+4, r25	; 0x04
    14e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    14ea:	eb 81       	ldd	r30, Y+3	; 0x03
    14ec:	fc 81       	ldd	r31, Y+4	; 0x04
    14ee:	80 e2       	ldi	r24, 0x20	; 32
    14f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f2:	8b 81       	ldd	r24, Y+3	; 0x03
    14f4:	9c 81       	ldd	r25, Y+4	; 0x04
    14f6:	01 97       	sbiw	r24, 0x01	; 1
    14f8:	9c 83       	std	Y+4, r25	; 0x04
    14fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    14fc:	eb 81       	ldd	r30, Y+3	; 0x03
    14fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1500:	81 e2       	ldi	r24, 0x21	; 33
    1502:	80 83       	st	Z, r24
	pxTopOfStack--;
    1504:	8b 81       	ldd	r24, Y+3	; 0x03
    1506:	9c 81       	ldd	r25, Y+4	; 0x04
    1508:	01 97       	sbiw	r24, 0x01	; 1
    150a:	9c 83       	std	Y+4, r25	; 0x04
    150c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    150e:	eb 81       	ldd	r30, Y+3	; 0x03
    1510:	fc 81       	ldd	r31, Y+4	; 0x04
    1512:	82 e2       	ldi	r24, 0x22	; 34
    1514:	80 83       	st	Z, r24
	pxTopOfStack--;
    1516:	8b 81       	ldd	r24, Y+3	; 0x03
    1518:	9c 81       	ldd	r25, Y+4	; 0x04
    151a:	01 97       	sbiw	r24, 0x01	; 1
    151c:	9c 83       	std	Y+4, r25	; 0x04
    151e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	83 e2       	ldi	r24, 0x23	; 35
    1526:	80 83       	st	Z, r24
	pxTopOfStack--;
    1528:	8b 81       	ldd	r24, Y+3	; 0x03
    152a:	9c 81       	ldd	r25, Y+4	; 0x04
    152c:	01 97       	sbiw	r24, 0x01	; 1
    152e:	9c 83       	std	Y+4, r25	; 0x04
    1530:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1532:	8f 81       	ldd	r24, Y+7	; 0x07
    1534:	98 85       	ldd	r25, Y+8	; 0x08
    1536:	9a 83       	std	Y+2, r25	; 0x02
    1538:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    153a:	89 81       	ldd	r24, Y+1	; 0x01
    153c:	eb 81       	ldd	r30, Y+3	; 0x03
    153e:	fc 81       	ldd	r31, Y+4	; 0x04
    1540:	80 83       	st	Z, r24
	pxTopOfStack--;
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	01 97       	sbiw	r24, 0x01	; 1
    1548:	9c 83       	std	Y+4, r25	; 0x04
    154a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	89 2f       	mov	r24, r25
    1552:	99 27       	eor	r25, r25
    1554:	9a 83       	std	Y+2, r25	; 0x02
    1556:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1558:	89 81       	ldd	r24, Y+1	; 0x01
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1560:	8b 81       	ldd	r24, Y+3	; 0x03
    1562:	9c 81       	ldd	r25, Y+4	; 0x04
    1564:	01 97       	sbiw	r24, 0x01	; 1
    1566:	9c 83       	std	Y+4, r25	; 0x04
    1568:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    156a:	eb 81       	ldd	r30, Y+3	; 0x03
    156c:	fc 81       	ldd	r31, Y+4	; 0x04
    156e:	86 e2       	ldi	r24, 0x26	; 38
    1570:	80 83       	st	Z, r24
	pxTopOfStack--;
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	9c 81       	ldd	r25, Y+4	; 0x04
    1576:	01 97       	sbiw	r24, 0x01	; 1
    1578:	9c 83       	std	Y+4, r25	; 0x04
    157a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    157c:	eb 81       	ldd	r30, Y+3	; 0x03
    157e:	fc 81       	ldd	r31, Y+4	; 0x04
    1580:	87 e2       	ldi	r24, 0x27	; 39
    1582:	80 83       	st	Z, r24
	pxTopOfStack--;
    1584:	8b 81       	ldd	r24, Y+3	; 0x03
    1586:	9c 81       	ldd	r25, Y+4	; 0x04
    1588:	01 97       	sbiw	r24, 0x01	; 1
    158a:	9c 83       	std	Y+4, r25	; 0x04
    158c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	88 e2       	ldi	r24, 0x28	; 40
    1594:	80 83       	st	Z, r24
	pxTopOfStack--;
    1596:	8b 81       	ldd	r24, Y+3	; 0x03
    1598:	9c 81       	ldd	r25, Y+4	; 0x04
    159a:	01 97       	sbiw	r24, 0x01	; 1
    159c:	9c 83       	std	Y+4, r25	; 0x04
    159e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	89 e2       	ldi	r24, 0x29	; 41
    15a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    15a8:	8b 81       	ldd	r24, Y+3	; 0x03
    15aa:	9c 81       	ldd	r25, Y+4	; 0x04
    15ac:	01 97       	sbiw	r24, 0x01	; 1
    15ae:	9c 83       	std	Y+4, r25	; 0x04
    15b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    15b2:	eb 81       	ldd	r30, Y+3	; 0x03
    15b4:	fc 81       	ldd	r31, Y+4	; 0x04
    15b6:	80 e3       	ldi	r24, 0x30	; 48
    15b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	9c 81       	ldd	r25, Y+4	; 0x04
    15be:	01 97       	sbiw	r24, 0x01	; 1
    15c0:	9c 83       	std	Y+4, r25	; 0x04
    15c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	81 e3       	ldi	r24, 0x31	; 49
    15ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    15cc:	8b 81       	ldd	r24, Y+3	; 0x03
    15ce:	9c 81       	ldd	r25, Y+4	; 0x04
    15d0:	01 97       	sbiw	r24, 0x01	; 1
    15d2:	9c 83       	std	Y+4, r25	; 0x04
    15d4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    15d6:	8b 81       	ldd	r24, Y+3	; 0x03
    15d8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    15da:	28 96       	adiw	r28, 0x08	; 8
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	de bf       	out	0x3e, r29	; 62
    15e2:	0f be       	out	0x3f, r0	; 63
    15e4:	cd bf       	out	0x3d, r28	; 61
    15e6:	cf 91       	pop	r28
    15e8:	df 91       	pop	r29
    15ea:	08 95       	ret

000015ec <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    15ec:	df 93       	push	r29
    15ee:	cf 93       	push	r28
    15f0:	cd b7       	in	r28, 0x3d	; 61
    15f2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    15f4:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    15f8:	a0 91 54 05 	lds	r26, 0x0554
    15fc:	b0 91 55 05 	lds	r27, 0x0555
    1600:	cd 91       	ld	r28, X+
    1602:	cd bf       	out	0x3d, r28	; 61
    1604:	dd 91       	ld	r29, X+
    1606:	de bf       	out	0x3e, r29	; 62
    1608:	ff 91       	pop	r31
    160a:	ef 91       	pop	r30
    160c:	df 91       	pop	r29
    160e:	cf 91       	pop	r28
    1610:	bf 91       	pop	r27
    1612:	af 91       	pop	r26
    1614:	9f 91       	pop	r25
    1616:	8f 91       	pop	r24
    1618:	7f 91       	pop	r23
    161a:	6f 91       	pop	r22
    161c:	5f 91       	pop	r21
    161e:	4f 91       	pop	r20
    1620:	3f 91       	pop	r19
    1622:	2f 91       	pop	r18
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	ff 90       	pop	r15
    162a:	ef 90       	pop	r14
    162c:	df 90       	pop	r13
    162e:	cf 90       	pop	r12
    1630:	bf 90       	pop	r11
    1632:	af 90       	pop	r10
    1634:	9f 90       	pop	r9
    1636:	8f 90       	pop	r8
    1638:	7f 90       	pop	r7
    163a:	6f 90       	pop	r6
    163c:	5f 90       	pop	r5
    163e:	4f 90       	pop	r4
    1640:	3f 90       	pop	r3
    1642:	2f 90       	pop	r2
    1644:	1f 90       	pop	r1
    1646:	0f 90       	pop	r0
    1648:	0f be       	out	0x3f, r0	; 63
    164a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    164c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    164e:	81 e0       	ldi	r24, 0x01	; 1
}
    1650:	cf 91       	pop	r28
    1652:	df 91       	pop	r29
    1654:	08 95       	ret

00001656 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1656:	df 93       	push	r29
    1658:	cf 93       	push	r28
    165a:	cd b7       	in	r28, 0x3d	; 61
    165c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    165e:	cf 91       	pop	r28
    1660:	df 91       	pop	r29
    1662:	08 95       	ret

00001664 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1664:	0f 92       	push	r0
    1666:	0f b6       	in	r0, 0x3f	; 63
    1668:	f8 94       	cli
    166a:	0f 92       	push	r0
    166c:	1f 92       	push	r1
    166e:	11 24       	eor	r1, r1
    1670:	2f 92       	push	r2
    1672:	3f 92       	push	r3
    1674:	4f 92       	push	r4
    1676:	5f 92       	push	r5
    1678:	6f 92       	push	r6
    167a:	7f 92       	push	r7
    167c:	8f 92       	push	r8
    167e:	9f 92       	push	r9
    1680:	af 92       	push	r10
    1682:	bf 92       	push	r11
    1684:	cf 92       	push	r12
    1686:	df 92       	push	r13
    1688:	ef 92       	push	r14
    168a:	ff 92       	push	r15
    168c:	0f 93       	push	r16
    168e:	1f 93       	push	r17
    1690:	2f 93       	push	r18
    1692:	3f 93       	push	r19
    1694:	4f 93       	push	r20
    1696:	5f 93       	push	r21
    1698:	6f 93       	push	r22
    169a:	7f 93       	push	r23
    169c:	8f 93       	push	r24
    169e:	9f 93       	push	r25
    16a0:	af 93       	push	r26
    16a2:	bf 93       	push	r27
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	ef 93       	push	r30
    16aa:	ff 93       	push	r31
    16ac:	a0 91 54 05 	lds	r26, 0x0554
    16b0:	b0 91 55 05 	lds	r27, 0x0555
    16b4:	0d b6       	in	r0, 0x3d	; 61
    16b6:	0d 92       	st	X+, r0
    16b8:	0e b6       	in	r0, 0x3e	; 62
    16ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    16bc:	0e 94 a2 14 	call	0x2944	; 0x2944 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    16c0:	a0 91 54 05 	lds	r26, 0x0554
    16c4:	b0 91 55 05 	lds	r27, 0x0555
    16c8:	cd 91       	ld	r28, X+
    16ca:	cd bf       	out	0x3d, r28	; 61
    16cc:	dd 91       	ld	r29, X+
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	ff 91       	pop	r31
    16d2:	ef 91       	pop	r30
    16d4:	df 91       	pop	r29
    16d6:	cf 91       	pop	r28
    16d8:	bf 91       	pop	r27
    16da:	af 91       	pop	r26
    16dc:	9f 91       	pop	r25
    16de:	8f 91       	pop	r24
    16e0:	7f 91       	pop	r23
    16e2:	6f 91       	pop	r22
    16e4:	5f 91       	pop	r21
    16e6:	4f 91       	pop	r20
    16e8:	3f 91       	pop	r19
    16ea:	2f 91       	pop	r18
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
    16f2:	ef 90       	pop	r14
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	bf 90       	pop	r11
    16fa:	af 90       	pop	r10
    16fc:	9f 90       	pop	r9
    16fe:	8f 90       	pop	r8
    1700:	7f 90       	pop	r7
    1702:	6f 90       	pop	r6
    1704:	5f 90       	pop	r5
    1706:	4f 90       	pop	r4
    1708:	3f 90       	pop	r3
    170a:	2f 90       	pop	r2
    170c:	1f 90       	pop	r1
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1714:	08 95       	ret

00001716 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1716:	0f 92       	push	r0
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	f8 94       	cli
    171c:	0f 92       	push	r0
    171e:	1f 92       	push	r1
    1720:	11 24       	eor	r1, r1
    1722:	2f 92       	push	r2
    1724:	3f 92       	push	r3
    1726:	4f 92       	push	r4
    1728:	5f 92       	push	r5
    172a:	6f 92       	push	r6
    172c:	7f 92       	push	r7
    172e:	8f 92       	push	r8
    1730:	9f 92       	push	r9
    1732:	af 92       	push	r10
    1734:	bf 92       	push	r11
    1736:	cf 92       	push	r12
    1738:	df 92       	push	r13
    173a:	ef 92       	push	r14
    173c:	ff 92       	push	r15
    173e:	0f 93       	push	r16
    1740:	1f 93       	push	r17
    1742:	2f 93       	push	r18
    1744:	3f 93       	push	r19
    1746:	4f 93       	push	r20
    1748:	5f 93       	push	r21
    174a:	6f 93       	push	r22
    174c:	7f 93       	push	r23
    174e:	8f 93       	push	r24
    1750:	9f 93       	push	r25
    1752:	af 93       	push	r26
    1754:	bf 93       	push	r27
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	ef 93       	push	r30
    175c:	ff 93       	push	r31
    175e:	a0 91 54 05 	lds	r26, 0x0554
    1762:	b0 91 55 05 	lds	r27, 0x0555
    1766:	0d b6       	in	r0, 0x3d	; 61
    1768:	0d 92       	st	X+, r0
    176a:	0e b6       	in	r0, 0x3e	; 62
    176c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    176e:	0e 94 cd 13 	call	0x279a	; 0x279a <vTaskIncrementTick>
	vTaskSwitchContext();
    1772:	0e 94 a2 14 	call	0x2944	; 0x2944 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1776:	a0 91 54 05 	lds	r26, 0x0554
    177a:	b0 91 55 05 	lds	r27, 0x0555
    177e:	cd 91       	ld	r28, X+
    1780:	cd bf       	out	0x3d, r28	; 61
    1782:	dd 91       	ld	r29, X+
    1784:	de bf       	out	0x3e, r29	; 62
    1786:	ff 91       	pop	r31
    1788:	ef 91       	pop	r30
    178a:	df 91       	pop	r29
    178c:	cf 91       	pop	r28
    178e:	bf 91       	pop	r27
    1790:	af 91       	pop	r26
    1792:	9f 91       	pop	r25
    1794:	8f 91       	pop	r24
    1796:	7f 91       	pop	r23
    1798:	6f 91       	pop	r22
    179a:	5f 91       	pop	r21
    179c:	4f 91       	pop	r20
    179e:	3f 91       	pop	r19
    17a0:	2f 91       	pop	r18
    17a2:	1f 91       	pop	r17
    17a4:	0f 91       	pop	r16
    17a6:	ff 90       	pop	r15
    17a8:	ef 90       	pop	r14
    17aa:	df 90       	pop	r13
    17ac:	cf 90       	pop	r12
    17ae:	bf 90       	pop	r11
    17b0:	af 90       	pop	r10
    17b2:	9f 90       	pop	r9
    17b4:	8f 90       	pop	r8
    17b6:	7f 90       	pop	r7
    17b8:	6f 90       	pop	r6
    17ba:	5f 90       	pop	r5
    17bc:	4f 90       	pop	r4
    17be:	3f 90       	pop	r3
    17c0:	2f 90       	pop	r2
    17c2:	1f 90       	pop	r1
    17c4:	0f 90       	pop	r0
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17ca:	08 95       	ret

000017cc <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    17cc:	df 93       	push	r29
    17ce:	cf 93       	push	r28
    17d0:	00 d0       	rcall	.+0      	; 0x17d2 <prvSetupTimerInterrupt+0x6>
    17d2:	00 d0       	rcall	.+0      	; 0x17d4 <prvSetupTimerInterrupt+0x8>
    17d4:	00 d0       	rcall	.+0      	; 0x17d6 <prvSetupTimerInterrupt+0xa>
    17d6:	cd b7       	in	r28, 0x3d	; 61
    17d8:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    17da:	80 e4       	ldi	r24, 0x40	; 64
    17dc:	9f e1       	ldi	r25, 0x1F	; 31
    17de:	a0 e0       	ldi	r26, 0x00	; 0
    17e0:	b0 e0       	ldi	r27, 0x00	; 0
    17e2:	8b 83       	std	Y+3, r24	; 0x03
    17e4:	9c 83       	std	Y+4, r25	; 0x04
    17e6:	ad 83       	std	Y+5, r26	; 0x05
    17e8:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	ad 81       	ldd	r26, Y+5	; 0x05
    17f0:	be 81       	ldd	r27, Y+6	; 0x06
    17f2:	68 94       	set
    17f4:	15 f8       	bld	r1, 5
    17f6:	b6 95       	lsr	r27
    17f8:	a7 95       	ror	r26
    17fa:	97 95       	ror	r25
    17fc:	87 95       	ror	r24
    17fe:	16 94       	lsr	r1
    1800:	d1 f7       	brne	.-12     	; 0x17f6 <prvSetupTimerInterrupt+0x2a>
    1802:	8b 83       	std	Y+3, r24	; 0x03
    1804:	9c 83       	std	Y+4, r25	; 0x04
    1806:	ad 83       	std	Y+5, r26	; 0x05
    1808:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    180a:	8b 81       	ldd	r24, Y+3	; 0x03
    180c:	9c 81       	ldd	r25, Y+4	; 0x04
    180e:	ad 81       	ldd	r26, Y+5	; 0x05
    1810:	be 81       	ldd	r27, Y+6	; 0x06
    1812:	01 97       	sbiw	r24, 0x01	; 1
    1814:	a1 09       	sbc	r26, r1
    1816:	b1 09       	sbc	r27, r1
    1818:	8b 83       	std	Y+3, r24	; 0x03
    181a:	9c 83       	std	Y+4, r25	; 0x04
    181c:	ad 83       	std	Y+5, r26	; 0x05
    181e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1820:	8b 81       	ldd	r24, Y+3	; 0x03
    1822:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1824:	8b 81       	ldd	r24, Y+3	; 0x03
    1826:	9c 81       	ldd	r25, Y+4	; 0x04
    1828:	ad 81       	ldd	r26, Y+5	; 0x05
    182a:	be 81       	ldd	r27, Y+6	; 0x06
    182c:	89 2f       	mov	r24, r25
    182e:	9a 2f       	mov	r25, r26
    1830:	ab 2f       	mov	r26, r27
    1832:	bb 27       	eor	r27, r27
    1834:	8b 83       	std	Y+3, r24	; 0x03
    1836:	9c 83       	std	Y+4, r25	; 0x04
    1838:	ad 83       	std	Y+5, r26	; 0x05
    183a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1840:	eb e4       	ldi	r30, 0x4B	; 75
    1842:	f0 e0       	ldi	r31, 0x00	; 0
    1844:	8a 81       	ldd	r24, Y+2	; 0x02
    1846:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1848:	ea e4       	ldi	r30, 0x4A	; 74
    184a:	f0 e0       	ldi	r31, 0x00	; 0
    184c:	89 81       	ldd	r24, Y+1	; 0x01
    184e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1850:	8b e0       	ldi	r24, 0x0B	; 11
    1852:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1854:	ee e4       	ldi	r30, 0x4E	; 78
    1856:	f0 e0       	ldi	r31, 0x00	; 0
    1858:	89 81       	ldd	r24, Y+1	; 0x01
    185a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    185c:	e9 e5       	ldi	r30, 0x59	; 89
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1864:	89 81       	ldd	r24, Y+1	; 0x01
    1866:	80 61       	ori	r24, 0x10	; 16
    1868:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    186a:	e9 e5       	ldi	r30, 0x59	; 89
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	89 81       	ldd	r24, Y+1	; 0x01
    1870:	80 83       	st	Z, r24
}
    1872:	26 96       	adiw	r28, 0x06	; 6
    1874:	0f b6       	in	r0, 0x3f	; 63
    1876:	f8 94       	cli
    1878:	de bf       	out	0x3e, r29	; 62
    187a:	0f be       	out	0x3f, r0	; 63
    187c:	cd bf       	out	0x3d, r28	; 61
    187e:	cf 91       	pop	r28
    1880:	df 91       	pop	r29
    1882:	08 95       	ret

00001884 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1884:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1888:	18 95       	reti

0000188a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    188a:	df 93       	push	r29
    188c:	cf 93       	push	r28
    188e:	cd b7       	in	r28, 0x3d	; 61
    1890:	de b7       	in	r29, 0x3e	; 62
    1892:	28 97       	sbiw	r28, 0x08	; 8
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	de bf       	out	0x3e, r29	; 62
    189a:	0f be       	out	0x3f, r0	; 63
    189c:	cd bf       	out	0x3d, r28	; 61
    189e:	8f 83       	std	Y+7, r24	; 0x07
    18a0:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    18a2:	1a 82       	std	Y+2, r1	; 0x02
    18a4:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    18a6:	8f 81       	ldd	r24, Y+7	; 0x07
    18a8:	88 23       	and	r24, r24
    18aa:	09 f4       	brne	.+2      	; 0x18ae <xQueueCreate+0x24>
    18ac:	8c c0       	rjmp	.+280    	; 0x19c6 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18ae:	8f e1       	ldi	r24, 0x1F	; 31
    18b0:	90 e0       	ldi	r25, 0x00	; 0
    18b2:	0e 94 14 07 	call	0xe28	; 0xe28 <pvPortMalloc>
    18b6:	9e 83       	std	Y+6, r25	; 0x06
    18b8:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    18ba:	8d 81       	ldd	r24, Y+5	; 0x05
    18bc:	9e 81       	ldd	r25, Y+6	; 0x06
    18be:	00 97       	sbiw	r24, 0x00	; 0
    18c0:	09 f4       	brne	.+2      	; 0x18c4 <xQueueCreate+0x3a>
    18c2:	81 c0       	rjmp	.+258    	; 0x19c6 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    18c4:	8f 81       	ldd	r24, Y+7	; 0x07
    18c6:	28 2f       	mov	r18, r24
    18c8:	30 e0       	ldi	r19, 0x00	; 0
    18ca:	88 85       	ldd	r24, Y+8	; 0x08
    18cc:	88 2f       	mov	r24, r24
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	ac 01       	movw	r20, r24
    18d2:	24 9f       	mul	r18, r20
    18d4:	c0 01       	movw	r24, r0
    18d6:	25 9f       	mul	r18, r21
    18d8:	90 0d       	add	r25, r0
    18da:	34 9f       	mul	r19, r20
    18dc:	90 0d       	add	r25, r0
    18de:	11 24       	eor	r1, r1
    18e0:	01 96       	adiw	r24, 0x01	; 1
    18e2:	9c 83       	std	Y+4, r25	; 0x04
    18e4:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    18e6:	8b 81       	ldd	r24, Y+3	; 0x03
    18e8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ea:	0e 94 14 07 	call	0xe28	; 0xe28 <pvPortMalloc>
    18ee:	ed 81       	ldd	r30, Y+5	; 0x05
    18f0:	fe 81       	ldd	r31, Y+6	; 0x06
    18f2:	91 83       	std	Z+1, r25	; 0x01
    18f4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    18f6:	ed 81       	ldd	r30, Y+5	; 0x05
    18f8:	fe 81       	ldd	r31, Y+6	; 0x06
    18fa:	80 81       	ld	r24, Z
    18fc:	91 81       	ldd	r25, Z+1	; 0x01
    18fe:	00 97       	sbiw	r24, 0x00	; 0
    1900:	09 f4       	brne	.+2      	; 0x1904 <xQueueCreate+0x7a>
    1902:	5d c0       	rjmp	.+186    	; 0x19be <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1904:	ed 81       	ldd	r30, Y+5	; 0x05
    1906:	fe 81       	ldd	r31, Y+6	; 0x06
    1908:	40 81       	ld	r20, Z
    190a:	51 81       	ldd	r21, Z+1	; 0x01
    190c:	8f 81       	ldd	r24, Y+7	; 0x07
    190e:	28 2f       	mov	r18, r24
    1910:	30 e0       	ldi	r19, 0x00	; 0
    1912:	88 85       	ldd	r24, Y+8	; 0x08
    1914:	88 2f       	mov	r24, r24
    1916:	90 e0       	ldi	r25, 0x00	; 0
    1918:	bc 01       	movw	r22, r24
    191a:	26 9f       	mul	r18, r22
    191c:	c0 01       	movw	r24, r0
    191e:	27 9f       	mul	r18, r23
    1920:	90 0d       	add	r25, r0
    1922:	36 9f       	mul	r19, r22
    1924:	90 0d       	add	r25, r0
    1926:	11 24       	eor	r1, r1
    1928:	84 0f       	add	r24, r20
    192a:	95 1f       	adc	r25, r21
    192c:	ed 81       	ldd	r30, Y+5	; 0x05
    192e:	fe 81       	ldd	r31, Y+6	; 0x06
    1930:	93 83       	std	Z+3, r25	; 0x03
    1932:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1934:	ed 81       	ldd	r30, Y+5	; 0x05
    1936:	fe 81       	ldd	r31, Y+6	; 0x06
    1938:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    193a:	ed 81       	ldd	r30, Y+5	; 0x05
    193c:	fe 81       	ldd	r31, Y+6	; 0x06
    193e:	80 81       	ld	r24, Z
    1940:	91 81       	ldd	r25, Z+1	; 0x01
    1942:	ed 81       	ldd	r30, Y+5	; 0x05
    1944:	fe 81       	ldd	r31, Y+6	; 0x06
    1946:	95 83       	std	Z+5, r25	; 0x05
    1948:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    194a:	ed 81       	ldd	r30, Y+5	; 0x05
    194c:	fe 81       	ldd	r31, Y+6	; 0x06
    194e:	40 81       	ld	r20, Z
    1950:	51 81       	ldd	r21, Z+1	; 0x01
    1952:	8f 81       	ldd	r24, Y+7	; 0x07
    1954:	88 2f       	mov	r24, r24
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	9c 01       	movw	r18, r24
    195a:	21 50       	subi	r18, 0x01	; 1
    195c:	30 40       	sbci	r19, 0x00	; 0
    195e:	88 85       	ldd	r24, Y+8	; 0x08
    1960:	88 2f       	mov	r24, r24
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	bc 01       	movw	r22, r24
    1966:	26 9f       	mul	r18, r22
    1968:	c0 01       	movw	r24, r0
    196a:	27 9f       	mul	r18, r23
    196c:	90 0d       	add	r25, r0
    196e:	36 9f       	mul	r19, r22
    1970:	90 0d       	add	r25, r0
    1972:	11 24       	eor	r1, r1
    1974:	84 0f       	add	r24, r20
    1976:	95 1f       	adc	r25, r21
    1978:	ed 81       	ldd	r30, Y+5	; 0x05
    197a:	fe 81       	ldd	r31, Y+6	; 0x06
    197c:	97 83       	std	Z+7, r25	; 0x07
    197e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1980:	ed 81       	ldd	r30, Y+5	; 0x05
    1982:	fe 81       	ldd	r31, Y+6	; 0x06
    1984:	8f 81       	ldd	r24, Y+7	; 0x07
    1986:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1988:	ed 81       	ldd	r30, Y+5	; 0x05
    198a:	fe 81       	ldd	r31, Y+6	; 0x06
    198c:	88 85       	ldd	r24, Y+8	; 0x08
    198e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1990:	ed 81       	ldd	r30, Y+5	; 0x05
    1992:	fe 81       	ldd	r31, Y+6	; 0x06
    1994:	8f ef       	ldi	r24, 0xFF	; 255
    1996:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1998:	ed 81       	ldd	r30, Y+5	; 0x05
    199a:	fe 81       	ldd	r31, Y+6	; 0x06
    199c:	8f ef       	ldi	r24, 0xFF	; 255
    199e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19a0:	8d 81       	ldd	r24, Y+5	; 0x05
    19a2:	9e 81       	ldd	r25, Y+6	; 0x06
    19a4:	08 96       	adiw	r24, 0x08	; 8
    19a6:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19aa:	8d 81       	ldd	r24, Y+5	; 0x05
    19ac:	9e 81       	ldd	r25, Y+6	; 0x06
    19ae:	41 96       	adiw	r24, 0x11	; 17
    19b0:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    19b4:	8d 81       	ldd	r24, Y+5	; 0x05
    19b6:	9e 81       	ldd	r25, Y+6	; 0x06
    19b8:	9a 83       	std	Y+2, r25	; 0x02
    19ba:	89 83       	std	Y+1, r24	; 0x01
    19bc:	04 c0       	rjmp	.+8      	; 0x19c6 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    19be:	8d 81       	ldd	r24, Y+5	; 0x05
    19c0:	9e 81       	ldd	r25, Y+6	; 0x06
    19c2:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    19c6:	89 81       	ldd	r24, Y+1	; 0x01
    19c8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    19ca:	28 96       	adiw	r28, 0x08	; 8
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	f8 94       	cli
    19d0:	de bf       	out	0x3e, r29	; 62
    19d2:	0f be       	out	0x3f, r0	; 63
    19d4:	cd bf       	out	0x3d, r28	; 61
    19d6:	cf 91       	pop	r28
    19d8:	df 91       	pop	r29
    19da:	08 95       	ret

000019dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    19dc:	df 93       	push	r29
    19de:	cf 93       	push	r28
    19e0:	cd b7       	in	r28, 0x3d	; 61
    19e2:	de b7       	in	r29, 0x3e	; 62
    19e4:	2c 97       	sbiw	r28, 0x0c	; 12
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	de bf       	out	0x3e, r29	; 62
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	cd bf       	out	0x3d, r28	; 61
    19f0:	9e 83       	std	Y+6, r25	; 0x06
    19f2:	8d 83       	std	Y+5, r24	; 0x05
    19f4:	78 87       	std	Y+8, r23	; 0x08
    19f6:	6f 83       	std	Y+7, r22	; 0x07
    19f8:	5a 87       	std	Y+10, r21	; 0x0a
    19fa:	49 87       	std	Y+9, r20	; 0x09
    19fc:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    19fe:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a06:	ed 81       	ldd	r30, Y+5	; 0x05
    1a08:	fe 81       	ldd	r31, Y+6	; 0x06
    1a0a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a0c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a0e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a10:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a12:	98 17       	cp	r25, r24
    1a14:	d8 f4       	brcc	.+54     	; 0x1a4c <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a16:	8d 81       	ldd	r24, Y+5	; 0x05
    1a18:	9e 81       	ldd	r25, Y+6	; 0x06
    1a1a:	2f 81       	ldd	r18, Y+7	; 0x07
    1a1c:	38 85       	ldd	r19, Y+8	; 0x08
    1a1e:	b9 01       	movw	r22, r18
    1a20:	4b 85       	ldd	r20, Y+11	; 0x0b
    1a22:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a26:	ed 81       	ldd	r30, Y+5	; 0x05
    1a28:	fe 81       	ldd	r31, Y+6	; 0x06
    1a2a:	81 89       	ldd	r24, Z+17	; 0x11
    1a2c:	88 23       	and	r24, r24
    1a2e:	49 f0       	breq	.+18     	; 0x1a42 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1a30:	8d 81       	ldd	r24, Y+5	; 0x05
    1a32:	9e 81       	ldd	r25, Y+6	; 0x06
    1a34:	41 96       	adiw	r24, 0x11	; 17
    1a36:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    1a3a:	81 30       	cpi	r24, 0x01	; 1
    1a3c:	11 f4       	brne	.+4      	; 0x1a42 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1a3e:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	8c 87       	std	Y+12, r24	; 0x0c
    1a4a:	5c c0       	rjmp	.+184    	; 0x1b04 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1a4c:	89 85       	ldd	r24, Y+9	; 0x09
    1a4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a50:	00 97       	sbiw	r24, 0x00	; 0
    1a52:	21 f4       	brne	.+8      	; 0x1a5c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a54:	0f 90       	pop	r0
    1a56:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a58:	1c 86       	std	Y+12, r1	; 0x0c
    1a5a:	54 c0       	rjmp	.+168    	; 0x1b04 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a5c:	89 81       	ldd	r24, Y+1	; 0x01
    1a5e:	88 23       	and	r24, r24
    1a60:	31 f4       	brne	.+12     	; 0x1a6e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a62:	ce 01       	movw	r24, r28
    1a64:	02 96       	adiw	r24, 0x02	; 2
    1a66:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a72:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	0f 92       	push	r0
    1a7c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a7e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a80:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a82:	8f 3f       	cpi	r24, 0xFF	; 255
    1a84:	19 f4       	brne	.+6      	; 0x1a8c <xQueueGenericSend+0xb0>
    1a86:	ed 81       	ldd	r30, Y+5	; 0x05
    1a88:	fe 81       	ldd	r31, Y+6	; 0x06
    1a8a:	15 8e       	std	Z+29, r1	; 0x1d
    1a8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a90:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a92:	8f 3f       	cpi	r24, 0xFF	; 255
    1a94:	19 f4       	brne	.+6      	; 0x1a9c <xQueueGenericSend+0xc0>
    1a96:	ed 81       	ldd	r30, Y+5	; 0x05
    1a98:	fe 81       	ldd	r31, Y+6	; 0x06
    1a9a:	16 8e       	std	Z+30, r1	; 0x1e
    1a9c:	0f 90       	pop	r0
    1a9e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aa0:	ce 01       	movw	r24, r28
    1aa2:	02 96       	adiw	r24, 0x02	; 2
    1aa4:	9e 01       	movw	r18, r28
    1aa6:	27 5f       	subi	r18, 0xF7	; 247
    1aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aaa:	b9 01       	movw	r22, r18
    1aac:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <xTaskCheckForTimeOut>
    1ab0:	88 23       	and	r24, r24
    1ab2:	09 f5       	brne	.+66     	; 0x1af6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ab4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ab6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ab8:	0e 94 8d 10 	call	0x211a	; 0x211a <prvIsQueueFull>
    1abc:	88 23       	and	r24, r24
    1abe:	a1 f0       	breq	.+40     	; 0x1ae8 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ac2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ac4:	08 96       	adiw	r24, 0x08	; 8
    1ac6:	29 85       	ldd	r18, Y+9	; 0x09
    1ac8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1aca:	b9 01       	movw	r22, r18
    1acc:	0e 94 08 15 	call	0x2a10	; 0x2a10 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1ad0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ad2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ad4:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ad8:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    1adc:	88 23       	and	r24, r24
    1ade:	09 f0       	breq	.+2      	; 0x1ae2 <xQueueGenericSend+0x106>
    1ae0:	8f cf       	rjmp	.-226    	; 0x1a00 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1ae2:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
    1ae6:	8c cf       	rjmp	.-232    	; 0x1a00 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ae8:	8d 81       	ldd	r24, Y+5	; 0x05
    1aea:	9e 81       	ldd	r25, Y+6	; 0x06
    1aec:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1af0:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    1af4:	85 cf       	rjmp	.-246    	; 0x1a00 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1af6:	8d 81       	ldd	r24, Y+5	; 0x05
    1af8:	9e 81       	ldd	r25, Y+6	; 0x06
    1afa:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1afe:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1b02:	1c 86       	std	Y+12, r1	; 0x0c
    1b04:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1b06:	2c 96       	adiw	r28, 0x0c	; 12
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	f8 94       	cli
    1b0c:	de bf       	out	0x3e, r29	; 62
    1b0e:	0f be       	out	0x3f, r0	; 63
    1b10:	cd bf       	out	0x3d, r28	; 61
    1b12:	cf 91       	pop	r28
    1b14:	df 91       	pop	r29
    1b16:	08 95       	ret

00001b18 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1b18:	df 93       	push	r29
    1b1a:	cf 93       	push	r28
    1b1c:	cd b7       	in	r28, 0x3d	; 61
    1b1e:	de b7       	in	r29, 0x3e	; 62
    1b20:	29 97       	sbiw	r28, 0x09	; 9
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	f8 94       	cli
    1b26:	de bf       	out	0x3e, r29	; 62
    1b28:	0f be       	out	0x3f, r0	; 63
    1b2a:	cd bf       	out	0x3d, r28	; 61
    1b2c:	9c 83       	std	Y+4, r25	; 0x04
    1b2e:	8b 83       	std	Y+3, r24	; 0x03
    1b30:	7e 83       	std	Y+6, r23	; 0x06
    1b32:	6d 83       	std	Y+5, r22	; 0x05
    1b34:	58 87       	std	Y+8, r21	; 0x08
    1b36:	4f 83       	std	Y+7, r20	; 0x07
    1b38:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b3a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b40:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b42:	eb 81       	ldd	r30, Y+3	; 0x03
    1b44:	fc 81       	ldd	r31, Y+4	; 0x04
    1b46:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b48:	98 17       	cp	r25, r24
    1b4a:	40 f5       	brcc	.+80     	; 0x1b9c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b50:	2d 81       	ldd	r18, Y+5	; 0x05
    1b52:	3e 81       	ldd	r19, Y+6	; 0x06
    1b54:	b9 01       	movw	r22, r18
    1b56:	49 85       	ldd	r20, Y+9	; 0x09
    1b58:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b62:	8f 3f       	cpi	r24, 0xFF	; 255
    1b64:	89 f4       	brne	.+34     	; 0x1b88 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b66:	eb 81       	ldd	r30, Y+3	; 0x03
    1b68:	fc 81       	ldd	r31, Y+4	; 0x04
    1b6a:	81 89       	ldd	r24, Z+17	; 0x11
    1b6c:	88 23       	and	r24, r24
    1b6e:	99 f0       	breq	.+38     	; 0x1b96 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b70:	8b 81       	ldd	r24, Y+3	; 0x03
    1b72:	9c 81       	ldd	r25, Y+4	; 0x04
    1b74:	41 96       	adiw	r24, 0x11	; 17
    1b76:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    1b7a:	88 23       	and	r24, r24
    1b7c:	61 f0       	breq	.+24     	; 0x1b96 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1b7e:	ef 81       	ldd	r30, Y+7	; 0x07
    1b80:	f8 85       	ldd	r31, Y+8	; 0x08
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	80 83       	st	Z, r24
    1b86:	07 c0       	rjmp	.+14     	; 0x1b96 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b88:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b8e:	8f 5f       	subi	r24, 0xFF	; 255
    1b90:	eb 81       	ldd	r30, Y+3	; 0x03
    1b92:	fc 81       	ldd	r31, Y+4	; 0x04
    1b94:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	8a 83       	std	Y+2, r24	; 0x02
    1b9a:	01 c0       	rjmp	.+2      	; 0x1b9e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b9c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b9e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ba0:	29 96       	adiw	r28, 0x09	; 9
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	de bf       	out	0x3e, r29	; 62
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	cd bf       	out	0x3d, r28	; 61
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1bb2:	df 93       	push	r29
    1bb4:	cf 93       	push	r28
    1bb6:	cd b7       	in	r28, 0x3d	; 61
    1bb8:	de b7       	in	r29, 0x3e	; 62
    1bba:	2e 97       	sbiw	r28, 0x0e	; 14
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	de bf       	out	0x3e, r29	; 62
    1bc2:	0f be       	out	0x3f, r0	; 63
    1bc4:	cd bf       	out	0x3d, r28	; 61
    1bc6:	98 87       	std	Y+8, r25	; 0x08
    1bc8:	8f 83       	std	Y+7, r24	; 0x07
    1bca:	7a 87       	std	Y+10, r23	; 0x0a
    1bcc:	69 87       	std	Y+9, r22	; 0x09
    1bce:	5c 87       	std	Y+12, r21	; 0x0c
    1bd0:	4b 87       	std	Y+11, r20	; 0x0b
    1bd2:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1bd4:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1bd6:	0f b6       	in	r0, 0x3f	; 63
    1bd8:	f8 94       	cli
    1bda:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1bdc:	ef 81       	ldd	r30, Y+7	; 0x07
    1bde:	f8 85       	ldd	r31, Y+8	; 0x08
    1be0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1be2:	88 23       	and	r24, r24
    1be4:	09 f4       	brne	.+2      	; 0x1be8 <xQueueGenericReceive+0x36>
    1be6:	3f c0       	rjmp	.+126    	; 0x1c66 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1be8:	ef 81       	ldd	r30, Y+7	; 0x07
    1bea:	f8 85       	ldd	r31, Y+8	; 0x08
    1bec:	86 81       	ldd	r24, Z+6	; 0x06
    1bee:	97 81       	ldd	r25, Z+7	; 0x07
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bf4:	8f 81       	ldd	r24, Y+7	; 0x07
    1bf6:	98 85       	ldd	r25, Y+8	; 0x08
    1bf8:	29 85       	ldd	r18, Y+9	; 0x09
    1bfa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1bfc:	b9 01       	movw	r22, r18
    1bfe:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1c02:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c04:	88 23       	and	r24, r24
    1c06:	b1 f4       	brne	.+44     	; 0x1c34 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1c08:	ef 81       	ldd	r30, Y+7	; 0x07
    1c0a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c0e:	81 50       	subi	r24, 0x01	; 1
    1c10:	ef 81       	ldd	r30, Y+7	; 0x07
    1c12:	f8 85       	ldd	r31, Y+8	; 0x08
    1c14:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c16:	ef 81       	ldd	r30, Y+7	; 0x07
    1c18:	f8 85       	ldd	r31, Y+8	; 0x08
    1c1a:	80 85       	ldd	r24, Z+8	; 0x08
    1c1c:	88 23       	and	r24, r24
    1c1e:	f1 f0       	breq	.+60     	; 0x1c5c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1c20:	8f 81       	ldd	r24, Y+7	; 0x07
    1c22:	98 85       	ldd	r25, Y+8	; 0x08
    1c24:	08 96       	adiw	r24, 0x08	; 8
    1c26:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    1c2a:	81 30       	cpi	r24, 0x01	; 1
    1c2c:	b9 f4       	brne	.+46     	; 0x1c5c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1c2e:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
    1c32:	14 c0       	rjmp	.+40     	; 0x1c5c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1c34:	ef 81       	ldd	r30, Y+7	; 0x07
    1c36:	f8 85       	ldd	r31, Y+8	; 0x08
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3c:	97 83       	std	Z+7, r25	; 0x07
    1c3e:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c40:	ef 81       	ldd	r30, Y+7	; 0x07
    1c42:	f8 85       	ldd	r31, Y+8	; 0x08
    1c44:	81 89       	ldd	r24, Z+17	; 0x11
    1c46:	88 23       	and	r24, r24
    1c48:	49 f0       	breq	.+18     	; 0x1c5c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c4a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c4c:	98 85       	ldd	r25, Y+8	; 0x08
    1c4e:	41 96       	adiw	r24, 0x11	; 17
    1c50:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    1c54:	88 23       	and	r24, r24
    1c56:	11 f0       	breq	.+4      	; 0x1c5c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1c58:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	8e 87       	std	Y+14, r24	; 0x0e
    1c64:	5c c0       	rjmp	.+184    	; 0x1d1e <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1c66:	8b 85       	ldd	r24, Y+11	; 0x0b
    1c68:	9c 85       	ldd	r25, Y+12	; 0x0c
    1c6a:	00 97       	sbiw	r24, 0x00	; 0
    1c6c:	21 f4       	brne	.+8      	; 0x1c76 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1c6e:	0f 90       	pop	r0
    1c70:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1c72:	1e 86       	std	Y+14, r1	; 0x0e
    1c74:	54 c0       	rjmp	.+168    	; 0x1d1e <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1c76:	8b 81       	ldd	r24, Y+3	; 0x03
    1c78:	88 23       	and	r24, r24
    1c7a:	31 f4       	brne	.+12     	; 0x1c88 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c7c:	ce 01       	movw	r24, r28
    1c7e:	04 96       	adiw	r24, 0x04	; 4
    1c80:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c8c:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	ef 81       	ldd	r30, Y+7	; 0x07
    1c98:	f8 85       	ldd	r31, Y+8	; 0x08
    1c9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c9c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c9e:	19 f4       	brne	.+6      	; 0x1ca6 <xQueueGenericReceive+0xf4>
    1ca0:	ef 81       	ldd	r30, Y+7	; 0x07
    1ca2:	f8 85       	ldd	r31, Y+8	; 0x08
    1ca4:	15 8e       	std	Z+29, r1	; 0x1d
    1ca6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ca8:	f8 85       	ldd	r31, Y+8	; 0x08
    1caa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cac:	8f 3f       	cpi	r24, 0xFF	; 255
    1cae:	19 f4       	brne	.+6      	; 0x1cb6 <xQueueGenericReceive+0x104>
    1cb0:	ef 81       	ldd	r30, Y+7	; 0x07
    1cb2:	f8 85       	ldd	r31, Y+8	; 0x08
    1cb4:	16 8e       	std	Z+30, r1	; 0x1e
    1cb6:	0f 90       	pop	r0
    1cb8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1cba:	ce 01       	movw	r24, r28
    1cbc:	04 96       	adiw	r24, 0x04	; 4
    1cbe:	9e 01       	movw	r18, r28
    1cc0:	25 5f       	subi	r18, 0xF5	; 245
    1cc2:	3f 4f       	sbci	r19, 0xFF	; 255
    1cc4:	b9 01       	movw	r22, r18
    1cc6:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <xTaskCheckForTimeOut>
    1cca:	88 23       	and	r24, r24
    1ccc:	09 f5       	brne	.+66     	; 0x1d10 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1cce:	8f 81       	ldd	r24, Y+7	; 0x07
    1cd0:	98 85       	ldd	r25, Y+8	; 0x08
    1cd2:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <prvIsQueueEmpty>
    1cd6:	88 23       	and	r24, r24
    1cd8:	a1 f0       	breq	.+40     	; 0x1d02 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1cda:	8f 81       	ldd	r24, Y+7	; 0x07
    1cdc:	98 85       	ldd	r25, Y+8	; 0x08
    1cde:	41 96       	adiw	r24, 0x11	; 17
    1ce0:	2b 85       	ldd	r18, Y+11	; 0x0b
    1ce2:	3c 85       	ldd	r19, Y+12	; 0x0c
    1ce4:	b9 01       	movw	r22, r18
    1ce6:	0e 94 08 15 	call	0x2a10	; 0x2a10 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1cea:	8f 81       	ldd	r24, Y+7	; 0x07
    1cec:	98 85       	ldd	r25, Y+8	; 0x08
    1cee:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1cf2:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    1cf6:	88 23       	and	r24, r24
    1cf8:	09 f0       	breq	.+2      	; 0x1cfc <xQueueGenericReceive+0x14a>
    1cfa:	6d cf       	rjmp	.-294    	; 0x1bd6 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1cfc:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
    1d00:	6a cf       	rjmp	.-300    	; 0x1bd6 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d02:	8f 81       	ldd	r24, Y+7	; 0x07
    1d04:	98 85       	ldd	r25, Y+8	; 0x08
    1d06:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d0a:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    1d0e:	63 cf       	rjmp	.-314    	; 0x1bd6 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1d10:	8f 81       	ldd	r24, Y+7	; 0x07
    1d12:	98 85       	ldd	r25, Y+8	; 0x08
    1d14:	0e 94 06 10 	call	0x200c	; 0x200c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d18:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1d1c:	1e 86       	std	Y+14, r1	; 0x0e
    1d1e:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1d20:	2e 96       	adiw	r28, 0x0e	; 14
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	de bf       	out	0x3e, r29	; 62
    1d28:	0f be       	out	0x3f, r0	; 63
    1d2a:	cd bf       	out	0x3d, r28	; 61
    1d2c:	cf 91       	pop	r28
    1d2e:	df 91       	pop	r29
    1d30:	08 95       	ret

00001d32 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1d32:	df 93       	push	r29
    1d34:	cf 93       	push	r28
    1d36:	cd b7       	in	r28, 0x3d	; 61
    1d38:	de b7       	in	r29, 0x3e	; 62
    1d3a:	28 97       	sbiw	r28, 0x08	; 8
    1d3c:	0f b6       	in	r0, 0x3f	; 63
    1d3e:	f8 94       	cli
    1d40:	de bf       	out	0x3e, r29	; 62
    1d42:	0f be       	out	0x3f, r0	; 63
    1d44:	cd bf       	out	0x3d, r28	; 61
    1d46:	9c 83       	std	Y+4, r25	; 0x04
    1d48:	8b 83       	std	Y+3, r24	; 0x03
    1d4a:	7e 83       	std	Y+6, r23	; 0x06
    1d4c:	6d 83       	std	Y+5, r22	; 0x05
    1d4e:	58 87       	std	Y+8, r21	; 0x08
    1d50:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1d52:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1d54:	eb 81       	ldd	r30, Y+3	; 0x03
    1d56:	fc 81       	ldd	r31, Y+4	; 0x04
    1d58:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d5a:	88 23       	and	r24, r24
    1d5c:	71 f1       	breq	.+92     	; 0x1dba <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d60:	9c 81       	ldd	r25, Y+4	; 0x04
    1d62:	2d 81       	ldd	r18, Y+5	; 0x05
    1d64:	3e 81       	ldd	r19, Y+6	; 0x06
    1d66:	b9 01       	movw	r22, r18
    1d68:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d70:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d72:	81 50       	subi	r24, 0x01	; 1
    1d74:	eb 81       	ldd	r30, Y+3	; 0x03
    1d76:	fc 81       	ldd	r31, Y+4	; 0x04
    1d78:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1d7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d80:	8f 3f       	cpi	r24, 0xFF	; 255
    1d82:	89 f4       	brne	.+34     	; 0x1da6 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d84:	eb 81       	ldd	r30, Y+3	; 0x03
    1d86:	fc 81       	ldd	r31, Y+4	; 0x04
    1d88:	80 85       	ldd	r24, Z+8	; 0x08
    1d8a:	88 23       	and	r24, r24
    1d8c:	99 f0       	breq	.+38     	; 0x1db4 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	08 96       	adiw	r24, 0x08	; 8
    1d94:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    1d98:	88 23       	and	r24, r24
    1d9a:	61 f0       	breq	.+24     	; 0x1db4 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1d9c:	ef 81       	ldd	r30, Y+7	; 0x07
    1d9e:	f8 85       	ldd	r31, Y+8	; 0x08
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	80 83       	st	Z, r24
    1da4:	07 c0       	rjmp	.+14     	; 0x1db4 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1da6:	eb 81       	ldd	r30, Y+3	; 0x03
    1da8:	fc 81       	ldd	r31, Y+4	; 0x04
    1daa:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dac:	8f 5f       	subi	r24, 0xFF	; 255
    1dae:	eb 81       	ldd	r30, Y+3	; 0x03
    1db0:	fc 81       	ldd	r31, Y+4	; 0x04
    1db2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	8a 83       	std	Y+2, r24	; 0x02
    1db8:	01 c0       	rjmp	.+2      	; 0x1dbc <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1dba:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1dbc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1dbe:	28 96       	adiw	r28, 0x08	; 8
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	f8 94       	cli
    1dc4:	de bf       	out	0x3e, r29	; 62
    1dc6:	0f be       	out	0x3f, r0	; 63
    1dc8:	cd bf       	out	0x3d, r28	; 61
    1dca:	cf 91       	pop	r28
    1dcc:	df 91       	pop	r29
    1dce:	08 95       	ret

00001dd0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	00 d0       	rcall	.+0      	; 0x1dd6 <uxQueueMessagesWaiting+0x6>
    1dd6:	0f 92       	push	r0
    1dd8:	cd b7       	in	r28, 0x3d	; 61
    1dda:	de b7       	in	r29, 0x3e	; 62
    1ddc:	9b 83       	std	Y+3, r25	; 0x03
    1dde:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1de0:	0f b6       	in	r0, 0x3f	; 63
    1de2:	f8 94       	cli
    1de4:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1de6:	ea 81       	ldd	r30, Y+2	; 0x02
    1de8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dec:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1dee:	0f 90       	pop	r0
    1df0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1df2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1df4:	0f 90       	pop	r0
    1df6:	0f 90       	pop	r0
    1df8:	0f 90       	pop	r0
    1dfa:	cf 91       	pop	r28
    1dfc:	df 91       	pop	r29
    1dfe:	08 95       	ret

00001e00 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1e00:	df 93       	push	r29
    1e02:	cf 93       	push	r28
    1e04:	00 d0       	rcall	.+0      	; 0x1e06 <uxQueueMessagesWaitingFromISR+0x6>
    1e06:	0f 92       	push	r0
    1e08:	cd b7       	in	r28, 0x3d	; 61
    1e0a:	de b7       	in	r29, 0x3e	; 62
    1e0c:	9b 83       	std	Y+3, r25	; 0x03
    1e0e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1e10:	ea 81       	ldd	r30, Y+2	; 0x02
    1e12:	fb 81       	ldd	r31, Y+3	; 0x03
    1e14:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e16:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e1a:	0f 90       	pop	r0
    1e1c:	0f 90       	pop	r0
    1e1e:	0f 90       	pop	r0
    1e20:	cf 91       	pop	r28
    1e22:	df 91       	pop	r29
    1e24:	08 95       	ret

00001e26 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1e26:	df 93       	push	r29
    1e28:	cf 93       	push	r28
    1e2a:	00 d0       	rcall	.+0      	; 0x1e2c <vQueueDelete+0x6>
    1e2c:	cd b7       	in	r28, 0x3d	; 61
    1e2e:	de b7       	in	r29, 0x3e	; 62
    1e30:	9a 83       	std	Y+2, r25	; 0x02
    1e32:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1e34:	e9 81       	ldd	r30, Y+1	; 0x01
    1e36:	fa 81       	ldd	r31, Y+2	; 0x02
    1e38:	80 81       	ld	r24, Z
    1e3a:	91 81       	ldd	r25, Z+1	; 0x01
    1e3c:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
	vPortFree( pxQueue );
    1e40:	89 81       	ldd	r24, Y+1	; 0x01
    1e42:	9a 81       	ldd	r25, Y+2	; 0x02
    1e44:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
}
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	cf 91       	pop	r28
    1e4e:	df 91       	pop	r29
    1e50:	08 95       	ret

00001e52 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1e52:	df 93       	push	r29
    1e54:	cf 93       	push	r28
    1e56:	00 d0       	rcall	.+0      	; 0x1e58 <prvCopyDataToQueue+0x6>
    1e58:	00 d0       	rcall	.+0      	; 0x1e5a <prvCopyDataToQueue+0x8>
    1e5a:	0f 92       	push	r0
    1e5c:	cd b7       	in	r28, 0x3d	; 61
    1e5e:	de b7       	in	r29, 0x3e	; 62
    1e60:	9a 83       	std	Y+2, r25	; 0x02
    1e62:	89 83       	std	Y+1, r24	; 0x01
    1e64:	7c 83       	std	Y+4, r23	; 0x04
    1e66:	6b 83       	std	Y+3, r22	; 0x03
    1e68:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1e6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e70:	88 23       	and	r24, r24
    1e72:	09 f4       	brne	.+2      	; 0x1e76 <prvCopyDataToQueue+0x24>
    1e74:	74 c0       	rjmp	.+232    	; 0x1f5e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1e76:	8d 81       	ldd	r24, Y+5	; 0x05
    1e78:	88 23       	and	r24, r24
    1e7a:	99 f5       	brne	.+102    	; 0x1ee2 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1e7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e80:	64 81       	ldd	r22, Z+4	; 0x04
    1e82:	75 81       	ldd	r23, Z+5	; 0x05
    1e84:	e9 81       	ldd	r30, Y+1	; 0x01
    1e86:	fa 81       	ldd	r31, Y+2	; 0x02
    1e88:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e8a:	48 2f       	mov	r20, r24
    1e8c:	50 e0       	ldi	r21, 0x00	; 0
    1e8e:	2b 81       	ldd	r18, Y+3	; 0x03
    1e90:	3c 81       	ldd	r19, Y+4	; 0x04
    1e92:	cb 01       	movw	r24, r22
    1e94:	b9 01       	movw	r22, r18
    1e96:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e9e:	24 81       	ldd	r18, Z+4	; 0x04
    1ea0:	35 81       	ldd	r19, Z+5	; 0x05
    1ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ea8:	88 2f       	mov	r24, r24
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	82 0f       	add	r24, r18
    1eae:	93 1f       	adc	r25, r19
    1eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb4:	95 83       	std	Z+5, r25	; 0x05
    1eb6:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eba:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebc:	24 81       	ldd	r18, Z+4	; 0x04
    1ebe:	35 81       	ldd	r19, Z+5	; 0x05
    1ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec4:	82 81       	ldd	r24, Z+2	; 0x02
    1ec6:	93 81       	ldd	r25, Z+3	; 0x03
    1ec8:	28 17       	cp	r18, r24
    1eca:	39 07       	cpc	r19, r25
    1ecc:	08 f4       	brcc	.+2      	; 0x1ed0 <prvCopyDataToQueue+0x7e>
    1ece:	47 c0       	rjmp	.+142    	; 0x1f5e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed4:	80 81       	ld	r24, Z
    1ed6:	91 81       	ldd	r25, Z+1	; 0x01
    1ed8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eda:	fa 81       	ldd	r31, Y+2	; 0x02
    1edc:	95 83       	std	Z+5, r25	; 0x05
    1ede:	84 83       	std	Z+4, r24	; 0x04
    1ee0:	3e c0       	rjmp	.+124    	; 0x1f5e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1ee2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee6:	66 81       	ldd	r22, Z+6	; 0x06
    1ee8:	77 81       	ldd	r23, Z+7	; 0x07
    1eea:	e9 81       	ldd	r30, Y+1	; 0x01
    1eec:	fa 81       	ldd	r31, Y+2	; 0x02
    1eee:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ef0:	48 2f       	mov	r20, r24
    1ef2:	50 e0       	ldi	r21, 0x00	; 0
    1ef4:	2b 81       	ldd	r18, Y+3	; 0x03
    1ef6:	3c 81       	ldd	r19, Y+4	; 0x04
    1ef8:	cb 01       	movw	r24, r22
    1efa:	b9 01       	movw	r22, r18
    1efc:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1f00:	e9 81       	ldd	r30, Y+1	; 0x01
    1f02:	fa 81       	ldd	r31, Y+2	; 0x02
    1f04:	26 81       	ldd	r18, Z+6	; 0x06
    1f06:	37 81       	ldd	r19, Z+7	; 0x07
    1f08:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f0e:	88 2f       	mov	r24, r24
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	90 95       	com	r25
    1f14:	81 95       	neg	r24
    1f16:	9f 4f       	sbci	r25, 0xFF	; 255
    1f18:	82 0f       	add	r24, r18
    1f1a:	93 1f       	adc	r25, r19
    1f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f20:	97 83       	std	Z+7, r25	; 0x07
    1f22:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1f24:	e9 81       	ldd	r30, Y+1	; 0x01
    1f26:	fa 81       	ldd	r31, Y+2	; 0x02
    1f28:	26 81       	ldd	r18, Z+6	; 0x06
    1f2a:	37 81       	ldd	r19, Z+7	; 0x07
    1f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f30:	80 81       	ld	r24, Z
    1f32:	91 81       	ldd	r25, Z+1	; 0x01
    1f34:	28 17       	cp	r18, r24
    1f36:	39 07       	cpc	r19, r25
    1f38:	90 f4       	brcc	.+36     	; 0x1f5e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3e:	22 81       	ldd	r18, Z+2	; 0x02
    1f40:	33 81       	ldd	r19, Z+3	; 0x03
    1f42:	e9 81       	ldd	r30, Y+1	; 0x01
    1f44:	fa 81       	ldd	r31, Y+2	; 0x02
    1f46:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f48:	88 2f       	mov	r24, r24
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	90 95       	com	r25
    1f4e:	81 95       	neg	r24
    1f50:	9f 4f       	sbci	r25, 0xFF	; 255
    1f52:	82 0f       	add	r24, r18
    1f54:	93 1f       	adc	r25, r19
    1f56:	e9 81       	ldd	r30, Y+1	; 0x01
    1f58:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5a:	97 83       	std	Z+7, r25	; 0x07
    1f5c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f60:	fa 81       	ldd	r31, Y+2	; 0x02
    1f62:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f64:	8f 5f       	subi	r24, 0xFF	; 255
    1f66:	e9 81       	ldd	r30, Y+1	; 0x01
    1f68:	fa 81       	ldd	r31, Y+2	; 0x02
    1f6a:	82 8f       	std	Z+26, r24	; 0x1a
}
    1f6c:	0f 90       	pop	r0
    1f6e:	0f 90       	pop	r0
    1f70:	0f 90       	pop	r0
    1f72:	0f 90       	pop	r0
    1f74:	0f 90       	pop	r0
    1f76:	cf 91       	pop	r28
    1f78:	df 91       	pop	r29
    1f7a:	08 95       	ret

00001f7c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	00 d0       	rcall	.+0      	; 0x1f82 <prvCopyDataFromQueue+0x6>
    1f82:	00 d0       	rcall	.+0      	; 0x1f84 <prvCopyDataFromQueue+0x8>
    1f84:	cd b7       	in	r28, 0x3d	; 61
    1f86:	de b7       	in	r29, 0x3e	; 62
    1f88:	9a 83       	std	Y+2, r25	; 0x02
    1f8a:	89 83       	std	Y+1, r24	; 0x01
    1f8c:	7c 83       	std	Y+4, r23	; 0x04
    1f8e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	80 81       	ld	r24, Z
    1f96:	91 81       	ldd	r25, Z+1	; 0x01
    1f98:	00 97       	sbiw	r24, 0x00	; 0
    1f9a:	89 f1       	breq	.+98     	; 0x1ffe <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa0:	26 81       	ldd	r18, Z+6	; 0x06
    1fa2:	37 81       	ldd	r19, Z+7	; 0x07
    1fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1faa:	88 2f       	mov	r24, r24
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 1f       	adc	r25, r19
    1fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb6:	97 83       	std	Z+7, r25	; 0x07
    1fb8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1fba:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1fbe:	26 81       	ldd	r18, Z+6	; 0x06
    1fc0:	37 81       	ldd	r19, Z+7	; 0x07
    1fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc6:	82 81       	ldd	r24, Z+2	; 0x02
    1fc8:	93 81       	ldd	r25, Z+3	; 0x03
    1fca:	28 17       	cp	r18, r24
    1fcc:	39 07       	cpc	r19, r25
    1fce:	40 f0       	brcs	.+16     	; 0x1fe0 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd4:	80 81       	ld	r24, Z
    1fd6:	91 81       	ldd	r25, Z+1	; 0x01
    1fd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fda:	fa 81       	ldd	r31, Y+2	; 0x02
    1fdc:	97 83       	std	Z+7, r25	; 0x07
    1fde:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fe4:	46 81       	ldd	r20, Z+6	; 0x06
    1fe6:	57 81       	ldd	r21, Z+7	; 0x07
    1fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fea:	fa 81       	ldd	r31, Y+2	; 0x02
    1fec:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fee:	28 2f       	mov	r18, r24
    1ff0:	30 e0       	ldi	r19, 0x00	; 0
    1ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff6:	ba 01       	movw	r22, r20
    1ff8:	a9 01       	movw	r20, r18
    1ffa:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <memcpy>
	}
}
    1ffe:	0f 90       	pop	r0
    2000:	0f 90       	pop	r0
    2002:	0f 90       	pop	r0
    2004:	0f 90       	pop	r0
    2006:	cf 91       	pop	r28
    2008:	df 91       	pop	r29
    200a:	08 95       	ret

0000200c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    200c:	df 93       	push	r29
    200e:	cf 93       	push	r28
    2010:	00 d0       	rcall	.+0      	; 0x2012 <prvUnlockQueue+0x6>
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
    2016:	9a 83       	std	Y+2, r25	; 0x02
    2018:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	0f 92       	push	r0
    2020:	15 c0       	rjmp	.+42     	; 0x204c <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2022:	e9 81       	ldd	r30, Y+1	; 0x01
    2024:	fa 81       	ldd	r31, Y+2	; 0x02
    2026:	81 89       	ldd	r24, Z+17	; 0x11
    2028:	88 23       	and	r24, r24
    202a:	a9 f0       	breq	.+42     	; 0x2056 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    202c:	89 81       	ldd	r24, Y+1	; 0x01
    202e:	9a 81       	ldd	r25, Y+2	; 0x02
    2030:	41 96       	adiw	r24, 0x11	; 17
    2032:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    2036:	88 23       	and	r24, r24
    2038:	11 f0       	breq	.+4      	; 0x203e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    203a:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    203e:	e9 81       	ldd	r30, Y+1	; 0x01
    2040:	fa 81       	ldd	r31, Y+2	; 0x02
    2042:	86 8d       	ldd	r24, Z+30	; 0x1e
    2044:	81 50       	subi	r24, 0x01	; 1
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    204c:	e9 81       	ldd	r30, Y+1	; 0x01
    204e:	fa 81       	ldd	r31, Y+2	; 0x02
    2050:	86 8d       	ldd	r24, Z+30	; 0x1e
    2052:	18 16       	cp	r1, r24
    2054:	34 f3       	brlt	.-52     	; 0x2022 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2056:	e9 81       	ldd	r30, Y+1	; 0x01
    2058:	fa 81       	ldd	r31, Y+2	; 0x02
    205a:	8f ef       	ldi	r24, 0xFF	; 255
    205c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    205e:	0f 90       	pop	r0
    2060:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2062:	0f b6       	in	r0, 0x3f	; 63
    2064:	f8 94       	cli
    2066:	0f 92       	push	r0
    2068:	15 c0       	rjmp	.+42     	; 0x2094 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    206a:	e9 81       	ldd	r30, Y+1	; 0x01
    206c:	fa 81       	ldd	r31, Y+2	; 0x02
    206e:	80 85       	ldd	r24, Z+8	; 0x08
    2070:	88 23       	and	r24, r24
    2072:	a9 f0       	breq	.+42     	; 0x209e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2074:	89 81       	ldd	r24, Y+1	; 0x01
    2076:	9a 81       	ldd	r25, Y+2	; 0x02
    2078:	08 96       	adiw	r24, 0x08	; 8
    207a:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <xTaskRemoveFromEventList>
    207e:	88 23       	and	r24, r24
    2080:	11 f0       	breq	.+4      	; 0x2086 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2082:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2086:	e9 81       	ldd	r30, Y+1	; 0x01
    2088:	fa 81       	ldd	r31, Y+2	; 0x02
    208a:	85 8d       	ldd	r24, Z+29	; 0x1d
    208c:	81 50       	subi	r24, 0x01	; 1
    208e:	e9 81       	ldd	r30, Y+1	; 0x01
    2090:	fa 81       	ldd	r31, Y+2	; 0x02
    2092:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2094:	e9 81       	ldd	r30, Y+1	; 0x01
    2096:	fa 81       	ldd	r31, Y+2	; 0x02
    2098:	85 8d       	ldd	r24, Z+29	; 0x1d
    209a:	18 16       	cp	r1, r24
    209c:	34 f3       	brlt	.-52     	; 0x206a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    209e:	e9 81       	ldd	r30, Y+1	; 0x01
    20a0:	fa 81       	ldd	r31, Y+2	; 0x02
    20a2:	8f ef       	ldi	r24, 0xFF	; 255
    20a4:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    20a6:	0f 90       	pop	r0
    20a8:	0f be       	out	0x3f, r0	; 63
}
    20aa:	0f 90       	pop	r0
    20ac:	0f 90       	pop	r0
    20ae:	cf 91       	pop	r28
    20b0:	df 91       	pop	r29
    20b2:	08 95       	ret

000020b4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    20b4:	df 93       	push	r29
    20b6:	cf 93       	push	r28
    20b8:	00 d0       	rcall	.+0      	; 0x20ba <prvIsQueueEmpty+0x6>
    20ba:	0f 92       	push	r0
    20bc:	cd b7       	in	r28, 0x3d	; 61
    20be:	de b7       	in	r29, 0x3e	; 62
    20c0:	9b 83       	std	Y+3, r25	; 0x03
    20c2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    20ca:	ea 81       	ldd	r30, Y+2	; 0x02
    20cc:	fb 81       	ldd	r31, Y+3	; 0x03
    20ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    20d0:	19 82       	std	Y+1, r1	; 0x01
    20d2:	88 23       	and	r24, r24
    20d4:	11 f4       	brne	.+4      	; 0x20da <prvIsQueueEmpty+0x26>
    20d6:	81 e0       	ldi	r24, 0x01	; 1
    20d8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20da:	0f 90       	pop	r0
    20dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    20de:	89 81       	ldd	r24, Y+1	; 0x01
}
    20e0:	0f 90       	pop	r0
    20e2:	0f 90       	pop	r0
    20e4:	0f 90       	pop	r0
    20e6:	cf 91       	pop	r28
    20e8:	df 91       	pop	r29
    20ea:	08 95       	ret

000020ec <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    20ec:	df 93       	push	r29
    20ee:	cf 93       	push	r28
    20f0:	00 d0       	rcall	.+0      	; 0x20f2 <xQueueIsQueueEmptyFromISR+0x6>
    20f2:	0f 92       	push	r0
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
    20f8:	9b 83       	std	Y+3, r25	; 0x03
    20fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    20fc:	ea 81       	ldd	r30, Y+2	; 0x02
    20fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2100:	82 8d       	ldd	r24, Z+26	; 0x1a
    2102:	19 82       	std	Y+1, r1	; 0x01
    2104:	88 23       	and	r24, r24
    2106:	11 f4       	brne	.+4      	; 0x210c <xQueueIsQueueEmptyFromISR+0x20>
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    210c:	89 81       	ldd	r24, Y+1	; 0x01
}
    210e:	0f 90       	pop	r0
    2110:	0f 90       	pop	r0
    2112:	0f 90       	pop	r0
    2114:	cf 91       	pop	r28
    2116:	df 91       	pop	r29
    2118:	08 95       	ret

0000211a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    211a:	df 93       	push	r29
    211c:	cf 93       	push	r28
    211e:	00 d0       	rcall	.+0      	; 0x2120 <prvIsQueueFull+0x6>
    2120:	0f 92       	push	r0
    2122:	cd b7       	in	r28, 0x3d	; 61
    2124:	de b7       	in	r29, 0x3e	; 62
    2126:	9b 83       	std	Y+3, r25	; 0x03
    2128:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    212a:	0f b6       	in	r0, 0x3f	; 63
    212c:	f8 94       	cli
    212e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2130:	ea 81       	ldd	r30, Y+2	; 0x02
    2132:	fb 81       	ldd	r31, Y+3	; 0x03
    2134:	92 8d       	ldd	r25, Z+26	; 0x1a
    2136:	ea 81       	ldd	r30, Y+2	; 0x02
    2138:	fb 81       	ldd	r31, Y+3	; 0x03
    213a:	83 8d       	ldd	r24, Z+27	; 0x1b
    213c:	19 82       	std	Y+1, r1	; 0x01
    213e:	98 17       	cp	r25, r24
    2140:	11 f4       	brne	.+4      	; 0x2146 <prvIsQueueFull+0x2c>
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2146:	0f 90       	pop	r0
    2148:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    214a:	89 81       	ldd	r24, Y+1	; 0x01
}
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	08 95       	ret

00002158 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	00 d0       	rcall	.+0      	; 0x215e <xQueueIsQueueFullFromISR+0x6>
    215e:	0f 92       	push	r0
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
    2164:	9b 83       	std	Y+3, r25	; 0x03
    2166:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2168:	ea 81       	ldd	r30, Y+2	; 0x02
    216a:	fb 81       	ldd	r31, Y+3	; 0x03
    216c:	92 8d       	ldd	r25, Z+26	; 0x1a
    216e:	ea 81       	ldd	r30, Y+2	; 0x02
    2170:	fb 81       	ldd	r31, Y+3	; 0x03
    2172:	83 8d       	ldd	r24, Z+27	; 0x1b
    2174:	19 82       	std	Y+1, r1	; 0x01
    2176:	98 17       	cp	r25, r24
    2178:	11 f4       	brne	.+4      	; 0x217e <xQueueIsQueueFullFromISR+0x26>
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    217e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2180:	0f 90       	pop	r0
    2182:	0f 90       	pop	r0
    2184:	0f 90       	pop	r0
    2186:	cf 91       	pop	r28
    2188:	df 91       	pop	r29
    218a:	08 95       	ret

0000218c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    218c:	af 92       	push	r10
    218e:	bf 92       	push	r11
    2190:	cf 92       	push	r12
    2192:	df 92       	push	r13
    2194:	ef 92       	push	r14
    2196:	ff 92       	push	r15
    2198:	0f 93       	push	r16
    219a:	1f 93       	push	r17
    219c:	df 93       	push	r29
    219e:	cf 93       	push	r28
    21a0:	cd b7       	in	r28, 0x3d	; 61
    21a2:	de b7       	in	r29, 0x3e	; 62
    21a4:	64 97       	sbiw	r28, 0x14	; 20
    21a6:	0f b6       	in	r0, 0x3f	; 63
    21a8:	f8 94       	cli
    21aa:	de bf       	out	0x3e, r29	; 62
    21ac:	0f be       	out	0x3f, r0	; 63
    21ae:	cd bf       	out	0x3d, r28	; 61
    21b0:	9f 83       	std	Y+7, r25	; 0x07
    21b2:	8e 83       	std	Y+6, r24	; 0x06
    21b4:	79 87       	std	Y+9, r23	; 0x09
    21b6:	68 87       	std	Y+8, r22	; 0x08
    21b8:	5b 87       	std	Y+11, r21	; 0x0b
    21ba:	4a 87       	std	Y+10, r20	; 0x0a
    21bc:	3d 87       	std	Y+13, r19	; 0x0d
    21be:	2c 87       	std	Y+12, r18	; 0x0c
    21c0:	0e 87       	std	Y+14, r16	; 0x0e
    21c2:	f8 8a       	std	Y+16, r15	; 0x10
    21c4:	ef 86       	std	Y+15, r14	; 0x0f
    21c6:	da 8a       	std	Y+18, r13	; 0x12
    21c8:	c9 8a       	std	Y+17, r12	; 0x11
    21ca:	bc 8a       	std	Y+20, r11	; 0x14
    21cc:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    21ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    21d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    21d2:	29 89       	ldd	r18, Y+17	; 0x11
    21d4:	3a 89       	ldd	r19, Y+18	; 0x12
    21d6:	b9 01       	movw	r22, r18
    21d8:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <prvAllocateTCBAndStack>
    21dc:	9c 83       	std	Y+4, r25	; 0x04
    21de:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    21e0:	8b 81       	ldd	r24, Y+3	; 0x03
    21e2:	9c 81       	ldd	r25, Y+4	; 0x04
    21e4:	00 97       	sbiw	r24, 0x00	; 0
    21e6:	09 f4       	brne	.+2      	; 0x21ea <xTaskGenericCreate+0x5e>
    21e8:	99 c0       	rjmp	.+306    	; 0x231c <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    21ea:	eb 81       	ldd	r30, Y+3	; 0x03
    21ec:	fc 81       	ldd	r31, Y+4	; 0x04
    21ee:	27 89       	ldd	r18, Z+23	; 0x17
    21f0:	30 8d       	ldd	r19, Z+24	; 0x18
    21f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    21f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    21f6:	01 97       	sbiw	r24, 0x01	; 1
    21f8:	82 0f       	add	r24, r18
    21fa:	93 1f       	adc	r25, r19
    21fc:	9a 83       	std	Y+2, r25	; 0x02
    21fe:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2200:	8b 81       	ldd	r24, Y+3	; 0x03
    2202:	9c 81       	ldd	r25, Y+4	; 0x04
    2204:	28 85       	ldd	r18, Y+8	; 0x08
    2206:	39 85       	ldd	r19, Y+9	; 0x09
    2208:	eb 89       	ldd	r30, Y+19	; 0x13
    220a:	fc 89       	ldd	r31, Y+20	; 0x14
    220c:	aa 85       	ldd	r26, Y+10	; 0x0a
    220e:	bb 85       	ldd	r27, Y+11	; 0x0b
    2210:	b9 01       	movw	r22, r18
    2212:	4e 85       	ldd	r20, Y+14	; 0x0e
    2214:	9f 01       	movw	r18, r30
    2216:	8d 01       	movw	r16, r26
    2218:	0e 94 30 16 	call	0x2c60	; 0x2c60 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    221c:	89 81       	ldd	r24, Y+1	; 0x01
    221e:	9a 81       	ldd	r25, Y+2	; 0x02
    2220:	2e 81       	ldd	r18, Y+6	; 0x06
    2222:	3f 81       	ldd	r19, Y+7	; 0x07
    2224:	4c 85       	ldd	r20, Y+12	; 0x0c
    2226:	5d 85       	ldd	r21, Y+13	; 0x0d
    2228:	b9 01       	movw	r22, r18
    222a:	0e 94 73 09 	call	0x12e6	; 0x12e6 <pxPortInitialiseStack>
    222e:	eb 81       	ldd	r30, Y+3	; 0x03
    2230:	fc 81       	ldd	r31, Y+4	; 0x04
    2232:	91 83       	std	Z+1, r25	; 0x01
    2234:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2236:	8f 85       	ldd	r24, Y+15	; 0x0f
    2238:	98 89       	ldd	r25, Y+16	; 0x10
    223a:	00 97       	sbiw	r24, 0x00	; 0
    223c:	31 f0       	breq	.+12     	; 0x224a <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    223e:	ef 85       	ldd	r30, Y+15	; 0x0f
    2240:	f8 89       	ldd	r31, Y+16	; 0x10
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	91 83       	std	Z+1, r25	; 0x01
    2248:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    224a:	0f b6       	in	r0, 0x3f	; 63
    224c:	f8 94       	cli
    224e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2250:	80 91 57 05 	lds	r24, 0x0557
    2254:	8f 5f       	subi	r24, 0xFF	; 255
    2256:	80 93 57 05 	sts	0x0557, r24
			if( pxCurrentTCB == NULL )
    225a:	80 91 54 05 	lds	r24, 0x0554
    225e:	90 91 55 05 	lds	r25, 0x0555
    2262:	00 97       	sbiw	r24, 0x00	; 0
    2264:	69 f4       	brne	.+26     	; 0x2280 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2266:	8b 81       	ldd	r24, Y+3	; 0x03
    2268:	9c 81       	ldd	r25, Y+4	; 0x04
    226a:	90 93 55 05 	sts	0x0555, r25
    226e:	80 93 54 05 	sts	0x0554, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2272:	80 91 57 05 	lds	r24, 0x0557
    2276:	81 30       	cpi	r24, 0x01	; 1
    2278:	a9 f4       	brne	.+42     	; 0x22a4 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    227a:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <prvInitialiseTaskLists>
    227e:	12 c0       	rjmp	.+36     	; 0x22a4 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2280:	80 91 5c 05 	lds	r24, 0x055C
    2284:	88 23       	and	r24, r24
    2286:	71 f4       	brne	.+28     	; 0x22a4 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2288:	e0 91 54 05 	lds	r30, 0x0554
    228c:	f0 91 55 05 	lds	r31, 0x0555
    2290:	96 89       	ldd	r25, Z+22	; 0x16
    2292:	8e 85       	ldd	r24, Y+14	; 0x0e
    2294:	89 17       	cp	r24, r25
    2296:	30 f0       	brcs	.+12     	; 0x22a4 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2298:	8b 81       	ldd	r24, Y+3	; 0x03
    229a:	9c 81       	ldd	r25, Y+4	; 0x04
    229c:	90 93 55 05 	sts	0x0555, r25
    22a0:	80 93 54 05 	sts	0x0554, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    22a4:	eb 81       	ldd	r30, Y+3	; 0x03
    22a6:	fc 81       	ldd	r31, Y+4	; 0x04
    22a8:	96 89       	ldd	r25, Z+22	; 0x16
    22aa:	80 91 5a 05 	lds	r24, 0x055A
    22ae:	89 17       	cp	r24, r25
    22b0:	28 f4       	brcc	.+10     	; 0x22bc <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    22b2:	eb 81       	ldd	r30, Y+3	; 0x03
    22b4:	fc 81       	ldd	r31, Y+4	; 0x04
    22b6:	86 89       	ldd	r24, Z+22	; 0x16
    22b8:	80 93 5a 05 	sts	0x055A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    22bc:	80 91 61 05 	lds	r24, 0x0561
    22c0:	8f 5f       	subi	r24, 0xFF	; 255
    22c2:	80 93 61 05 	sts	0x0561, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	96 89       	ldd	r25, Z+22	; 0x16
    22cc:	80 91 5b 05 	lds	r24, 0x055B
    22d0:	89 17       	cp	r24, r25
    22d2:	28 f4       	brcc	.+10     	; 0x22de <xTaskGenericCreate+0x152>
    22d4:	eb 81       	ldd	r30, Y+3	; 0x03
    22d6:	fc 81       	ldd	r31, Y+4	; 0x04
    22d8:	86 89       	ldd	r24, Z+22	; 0x16
    22da:	80 93 5b 05 	sts	0x055B, r24
    22de:	eb 81       	ldd	r30, Y+3	; 0x03
    22e0:	fc 81       	ldd	r31, Y+4	; 0x04
    22e2:	86 89       	ldd	r24, Z+22	; 0x16
    22e4:	28 2f       	mov	r18, r24
    22e6:	30 e0       	ldi	r19, 0x00	; 0
    22e8:	c9 01       	movw	r24, r18
    22ea:	88 0f       	add	r24, r24
    22ec:	99 1f       	adc	r25, r25
    22ee:	88 0f       	add	r24, r24
    22f0:	99 1f       	adc	r25, r25
    22f2:	88 0f       	add	r24, r24
    22f4:	99 1f       	adc	r25, r25
    22f6:	82 0f       	add	r24, r18
    22f8:	93 1f       	adc	r25, r19
    22fa:	ac 01       	movw	r20, r24
    22fc:	4e 59       	subi	r20, 0x9E	; 158
    22fe:	5a 4f       	sbci	r21, 0xFA	; 250
    2300:	8b 81       	ldd	r24, Y+3	; 0x03
    2302:	9c 81       	ldd	r25, Y+4	; 0x04
    2304:	9c 01       	movw	r18, r24
    2306:	2e 5f       	subi	r18, 0xFE	; 254
    2308:	3f 4f       	sbci	r19, 0xFF	; 255
    230a:	ca 01       	movw	r24, r20
    230c:	b9 01       	movw	r22, r18
    230e:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>

			xReturn = pdPASS;
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2316:	0f 90       	pop	r0
    2318:	0f be       	out	0x3f, r0	; 63
    231a:	02 c0       	rjmp	.+4      	; 0x2320 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    231c:	8f ef       	ldi	r24, 0xFF	; 255
    231e:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2320:	8d 81       	ldd	r24, Y+5	; 0x05
    2322:	81 30       	cpi	r24, 0x01	; 1
    2324:	71 f4       	brne	.+28     	; 0x2342 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2326:	80 91 5c 05 	lds	r24, 0x055C
    232a:	88 23       	and	r24, r24
    232c:	51 f0       	breq	.+20     	; 0x2342 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    232e:	e0 91 54 05 	lds	r30, 0x0554
    2332:	f0 91 55 05 	lds	r31, 0x0555
    2336:	96 89       	ldd	r25, Z+22	; 0x16
    2338:	8e 85       	ldd	r24, Y+14	; 0x0e
    233a:	98 17       	cp	r25, r24
    233c:	10 f4       	brcc	.+4      	; 0x2342 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    233e:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
			}
		}
	}

	return xReturn;
    2342:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2344:	64 96       	adiw	r28, 0x14	; 20
    2346:	0f b6       	in	r0, 0x3f	; 63
    2348:	f8 94       	cli
    234a:	de bf       	out	0x3e, r29	; 62
    234c:	0f be       	out	0x3f, r0	; 63
    234e:	cd bf       	out	0x3d, r28	; 61
    2350:	cf 91       	pop	r28
    2352:	df 91       	pop	r29
    2354:	1f 91       	pop	r17
    2356:	0f 91       	pop	r16
    2358:	ff 90       	pop	r15
    235a:	ef 90       	pop	r14
    235c:	df 90       	pop	r13
    235e:	cf 90       	pop	r12
    2360:	bf 90       	pop	r11
    2362:	af 90       	pop	r10
    2364:	08 95       	ret

00002366 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2366:	df 93       	push	r29
    2368:	cf 93       	push	r28
    236a:	00 d0       	rcall	.+0      	; 0x236c <vTaskDelete+0x6>
    236c:	00 d0       	rcall	.+0      	; 0x236e <vTaskDelete+0x8>
    236e:	00 d0       	rcall	.+0      	; 0x2370 <vTaskDelete+0xa>
    2370:	cd b7       	in	r28, 0x3d	; 61
    2372:	de b7       	in	r29, 0x3e	; 62
    2374:	9c 83       	std	Y+4, r25	; 0x04
    2376:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2378:	0f b6       	in	r0, 0x3f	; 63
    237a:	f8 94       	cli
    237c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    237e:	20 91 54 05 	lds	r18, 0x0554
    2382:	30 91 55 05 	lds	r19, 0x0555
    2386:	8b 81       	ldd	r24, Y+3	; 0x03
    2388:	9c 81       	ldd	r25, Y+4	; 0x04
    238a:	82 17       	cp	r24, r18
    238c:	93 07       	cpc	r25, r19
    238e:	11 f4       	brne	.+4      	; 0x2394 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2390:	1c 82       	std	Y+4, r1	; 0x04
    2392:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	00 97       	sbiw	r24, 0x00	; 0
    239a:	39 f4       	brne	.+14     	; 0x23aa <vTaskDelete+0x44>
    239c:	80 91 54 05 	lds	r24, 0x0554
    23a0:	90 91 55 05 	lds	r25, 0x0555
    23a4:	9e 83       	std	Y+6, r25	; 0x06
    23a6:	8d 83       	std	Y+5, r24	; 0x05
    23a8:	04 c0       	rjmp	.+8      	; 0x23b2 <vTaskDelete+0x4c>
    23aa:	8b 81       	ldd	r24, Y+3	; 0x03
    23ac:	9c 81       	ldd	r25, Y+4	; 0x04
    23ae:	9e 83       	std	Y+6, r25	; 0x06
    23b0:	8d 83       	std	Y+5, r24	; 0x05
    23b2:	8d 81       	ldd	r24, Y+5	; 0x05
    23b4:	9e 81       	ldd	r25, Y+6	; 0x06
    23b6:	9a 83       	std	Y+2, r25	; 0x02
    23b8:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    23ba:	89 81       	ldd	r24, Y+1	; 0x01
    23bc:	9a 81       	ldd	r25, Y+2	; 0x02
    23be:	02 96       	adiw	r24, 0x02	; 2
    23c0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    23c4:	e9 81       	ldd	r30, Y+1	; 0x01
    23c6:	fa 81       	ldd	r31, Y+2	; 0x02
    23c8:	84 89       	ldd	r24, Z+20	; 0x14
    23ca:	95 89       	ldd	r25, Z+21	; 0x15
    23cc:	00 97       	sbiw	r24, 0x00	; 0
    23ce:	29 f0       	breq	.+10     	; 0x23da <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    23d0:	89 81       	ldd	r24, Y+1	; 0x01
    23d2:	9a 81       	ldd	r25, Y+2	; 0x02
    23d4:	0c 96       	adiw	r24, 0x0c	; 12
    23d6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	9a 81       	ldd	r25, Y+2	; 0x02
    23de:	9c 01       	movw	r18, r24
    23e0:	2e 5f       	subi	r18, 0xFE	; 254
    23e2:	3f 4f       	sbci	r19, 0xFF	; 255
    23e4:	82 ed       	ldi	r24, 0xD2	; 210
    23e6:	95 e0       	ldi	r25, 0x05	; 5
    23e8:	b9 01       	movw	r22, r18
    23ea:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    23ee:	80 91 56 05 	lds	r24, 0x0556
    23f2:	8f 5f       	subi	r24, 0xFF	; 255
    23f4:	80 93 56 05 	sts	0x0556, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    23f8:	80 91 61 05 	lds	r24, 0x0561
    23fc:	8f 5f       	subi	r24, 0xFF	; 255
    23fe:	80 93 61 05 	sts	0x0561, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2402:	0f 90       	pop	r0
    2404:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2406:	80 91 5c 05 	lds	r24, 0x055C
    240a:	88 23       	and	r24, r24
    240c:	31 f0       	breq	.+12     	; 0x241a <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    240e:	8b 81       	ldd	r24, Y+3	; 0x03
    2410:	9c 81       	ldd	r25, Y+4	; 0x04
    2412:	00 97       	sbiw	r24, 0x00	; 0
    2414:	11 f4       	brne	.+4      	; 0x241a <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2416:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
			}
		}
	}
    241a:	26 96       	adiw	r28, 0x06	; 6
    241c:	0f b6       	in	r0, 0x3f	; 63
    241e:	f8 94       	cli
    2420:	de bf       	out	0x3e, r29	; 62
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	cd bf       	out	0x3d, r28	; 61
    2426:	cf 91       	pop	r28
    2428:	df 91       	pop	r29
    242a:	08 95       	ret

0000242c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    242c:	df 93       	push	r29
    242e:	cf 93       	push	r28
    2430:	cd b7       	in	r28, 0x3d	; 61
    2432:	de b7       	in	r29, 0x3e	; 62
    2434:	28 97       	sbiw	r28, 0x08	; 8
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	de bf       	out	0x3e, r29	; 62
    243c:	0f be       	out	0x3f, r0	; 63
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	9e 83       	std	Y+6, r25	; 0x06
    2442:	8d 83       	std	Y+5, r24	; 0x05
    2444:	78 87       	std	Y+8, r23	; 0x08
    2446:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2448:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    244a:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    244e:	ed 81       	ldd	r30, Y+5	; 0x05
    2450:	fe 81       	ldd	r31, Y+6	; 0x06
    2452:	20 81       	ld	r18, Z
    2454:	31 81       	ldd	r19, Z+1	; 0x01
    2456:	8f 81       	ldd	r24, Y+7	; 0x07
    2458:	98 85       	ldd	r25, Y+8	; 0x08
    245a:	82 0f       	add	r24, r18
    245c:	93 1f       	adc	r25, r19
    245e:	9c 83       	std	Y+4, r25	; 0x04
    2460:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2462:	ed 81       	ldd	r30, Y+5	; 0x05
    2464:	fe 81       	ldd	r31, Y+6	; 0x06
    2466:	20 81       	ld	r18, Z
    2468:	31 81       	ldd	r19, Z+1	; 0x01
    246a:	80 91 58 05 	lds	r24, 0x0558
    246e:	90 91 59 05 	lds	r25, 0x0559
    2472:	82 17       	cp	r24, r18
    2474:	93 07       	cpc	r25, r19
    2476:	a8 f4       	brcc	.+42     	; 0x24a2 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2478:	ed 81       	ldd	r30, Y+5	; 0x05
    247a:	fe 81       	ldd	r31, Y+6	; 0x06
    247c:	20 81       	ld	r18, Z
    247e:	31 81       	ldd	r19, Z+1	; 0x01
    2480:	8b 81       	ldd	r24, Y+3	; 0x03
    2482:	9c 81       	ldd	r25, Y+4	; 0x04
    2484:	82 17       	cp	r24, r18
    2486:	93 07       	cpc	r25, r19
    2488:	00 f5       	brcc	.+64     	; 0x24ca <vTaskDelayUntil+0x9e>
    248a:	20 91 58 05 	lds	r18, 0x0558
    248e:	30 91 59 05 	lds	r19, 0x0559
    2492:	8b 81       	ldd	r24, Y+3	; 0x03
    2494:	9c 81       	ldd	r25, Y+4	; 0x04
    2496:	28 17       	cp	r18, r24
    2498:	39 07       	cpc	r19, r25
    249a:	b8 f4       	brcc	.+46     	; 0x24ca <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    249c:	81 e0       	ldi	r24, 0x01	; 1
    249e:	89 83       	std	Y+1, r24	; 0x01
    24a0:	14 c0       	rjmp	.+40     	; 0x24ca <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24a2:	ed 81       	ldd	r30, Y+5	; 0x05
    24a4:	fe 81       	ldd	r31, Y+6	; 0x06
    24a6:	20 81       	ld	r18, Z
    24a8:	31 81       	ldd	r19, Z+1	; 0x01
    24aa:	8b 81       	ldd	r24, Y+3	; 0x03
    24ac:	9c 81       	ldd	r25, Y+4	; 0x04
    24ae:	82 17       	cp	r24, r18
    24b0:	93 07       	cpc	r25, r19
    24b2:	48 f0       	brcs	.+18     	; 0x24c6 <vTaskDelayUntil+0x9a>
    24b4:	20 91 58 05 	lds	r18, 0x0558
    24b8:	30 91 59 05 	lds	r19, 0x0559
    24bc:	8b 81       	ldd	r24, Y+3	; 0x03
    24be:	9c 81       	ldd	r25, Y+4	; 0x04
    24c0:	28 17       	cp	r18, r24
    24c2:	39 07       	cpc	r19, r25
    24c4:	10 f4       	brcc	.+4      	; 0x24ca <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24ca:	ed 81       	ldd	r30, Y+5	; 0x05
    24cc:	fe 81       	ldd	r31, Y+6	; 0x06
    24ce:	8b 81       	ldd	r24, Y+3	; 0x03
    24d0:	9c 81       	ldd	r25, Y+4	; 0x04
    24d2:	91 83       	std	Z+1, r25	; 0x01
    24d4:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    24d6:	89 81       	ldd	r24, Y+1	; 0x01
    24d8:	88 23       	and	r24, r24
    24da:	59 f0       	breq	.+22     	; 0x24f2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24dc:	80 91 54 05 	lds	r24, 0x0554
    24e0:	90 91 55 05 	lds	r25, 0x0555
    24e4:	02 96       	adiw	r24, 0x02	; 2
    24e6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24ea:	8b 81       	ldd	r24, Y+3	; 0x03
    24ec:	9c 81       	ldd	r25, Y+4	; 0x04
    24ee:	0e 94 02 17 	call	0x2e04	; 0x2e04 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24f2:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    24f6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24f8:	8a 81       	ldd	r24, Y+2	; 0x02
    24fa:	88 23       	and	r24, r24
    24fc:	11 f4       	brne	.+4      	; 0x2502 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    24fe:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
		}
	}
    2502:	28 96       	adiw	r28, 0x08	; 8
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	f8 94       	cli
    2508:	de bf       	out	0x3e, r29	; 62
    250a:	0f be       	out	0x3f, r0	; 63
    250c:	cd bf       	out	0x3d, r28	; 61
    250e:	cf 91       	pop	r28
    2510:	df 91       	pop	r29
    2512:	08 95       	ret

00002514 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2514:	df 93       	push	r29
    2516:	cf 93       	push	r28
    2518:	00 d0       	rcall	.+0      	; 0x251a <vTaskDelay+0x6>
    251a:	00 d0       	rcall	.+0      	; 0x251c <vTaskDelay+0x8>
    251c:	0f 92       	push	r0
    251e:	cd b7       	in	r28, 0x3d	; 61
    2520:	de b7       	in	r29, 0x3e	; 62
    2522:	9d 83       	std	Y+5, r25	; 0x05
    2524:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2526:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2528:	8c 81       	ldd	r24, Y+4	; 0x04
    252a:	9d 81       	ldd	r25, Y+5	; 0x05
    252c:	00 97       	sbiw	r24, 0x00	; 0
    252e:	d1 f0       	breq	.+52     	; 0x2564 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2530:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2534:	20 91 58 05 	lds	r18, 0x0558
    2538:	30 91 59 05 	lds	r19, 0x0559
    253c:	8c 81       	ldd	r24, Y+4	; 0x04
    253e:	9d 81       	ldd	r25, Y+5	; 0x05
    2540:	82 0f       	add	r24, r18
    2542:	93 1f       	adc	r25, r19
    2544:	9b 83       	std	Y+3, r25	; 0x03
    2546:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2548:	80 91 54 05 	lds	r24, 0x0554
    254c:	90 91 55 05 	lds	r25, 0x0555
    2550:	02 96       	adiw	r24, 0x02	; 2
    2552:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2556:	8a 81       	ldd	r24, Y+2	; 0x02
    2558:	9b 81       	ldd	r25, Y+3	; 0x03
    255a:	0e 94 02 17 	call	0x2e04	; 0x2e04 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    255e:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>
    2562:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2564:	89 81       	ldd	r24, Y+1	; 0x01
    2566:	88 23       	and	r24, r24
    2568:	11 f4       	brne	.+4      	; 0x256e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    256a:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
		}
	}
    256e:	0f 90       	pop	r0
    2570:	0f 90       	pop	r0
    2572:	0f 90       	pop	r0
    2574:	0f 90       	pop	r0
    2576:	0f 90       	pop	r0
    2578:	cf 91       	pop	r28
    257a:	df 91       	pop	r29
    257c:	08 95       	ret

0000257e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    257e:	af 92       	push	r10
    2580:	bf 92       	push	r11
    2582:	cf 92       	push	r12
    2584:	df 92       	push	r13
    2586:	ef 92       	push	r14
    2588:	ff 92       	push	r15
    258a:	0f 93       	push	r16
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	0f 92       	push	r0
    2592:	cd b7       	in	r28, 0x3d	; 61
    2594:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2596:	20 e6       	ldi	r18, 0x60	; 96
    2598:	30 e0       	ldi	r19, 0x00	; 0
    259a:	86 e2       	ldi	r24, 0x26	; 38
    259c:	96 e1       	ldi	r25, 0x16	; 22
    259e:	b9 01       	movw	r22, r18
    25a0:	4b e9       	ldi	r20, 0x9B	; 155
    25a2:	50 e0       	ldi	r21, 0x00	; 0
    25a4:	20 e0       	ldi	r18, 0x00	; 0
    25a6:	30 e0       	ldi	r19, 0x00	; 0
    25a8:	00 e0       	ldi	r16, 0x00	; 0
    25aa:	ee 24       	eor	r14, r14
    25ac:	ff 24       	eor	r15, r15
    25ae:	cc 24       	eor	r12, r12
    25b0:	dd 24       	eor	r13, r13
    25b2:	aa 24       	eor	r10, r10
    25b4:	bb 24       	eor	r11, r11
    25b6:	0e 94 c6 10 	call	0x218c	; 0x218c <xTaskGenericCreate>
    25ba:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    25bc:	89 81       	ldd	r24, Y+1	; 0x01
    25be:	81 30       	cpi	r24, 0x01	; 1
    25c0:	51 f4       	brne	.+20     	; 0x25d6 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    25c2:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    25c4:	81 e0       	ldi	r24, 0x01	; 1
    25c6:	80 93 5c 05 	sts	0x055C, r24
		xTickCount = ( portTickType ) 0U;
    25ca:	10 92 59 05 	sts	0x0559, r1
    25ce:	10 92 58 05 	sts	0x0558, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    25d2:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    25d6:	0f 90       	pop	r0
    25d8:	cf 91       	pop	r28
    25da:	df 91       	pop	r29
    25dc:	0f 91       	pop	r16
    25de:	ff 90       	pop	r15
    25e0:	ef 90       	pop	r14
    25e2:	df 90       	pop	r13
    25e4:	cf 90       	pop	r12
    25e6:	bf 90       	pop	r11
    25e8:	af 90       	pop	r10
    25ea:	08 95       	ret

000025ec <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    25ec:	df 93       	push	r29
    25ee:	cf 93       	push	r28
    25f0:	cd b7       	in	r28, 0x3d	; 61
    25f2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    25f4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    25f6:	10 92 5c 05 	sts	0x055C, r1
	vPortEndScheduler();
    25fa:	0e 94 2b 0b 	call	0x1656	; 0x1656 <vPortEndScheduler>
}
    25fe:	cf 91       	pop	r28
    2600:	df 91       	pop	r29
    2602:	08 95       	ret

00002604 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2604:	df 93       	push	r29
    2606:	cf 93       	push	r28
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    260c:	80 91 5d 05 	lds	r24, 0x055D
    2610:	8f 5f       	subi	r24, 0xFF	; 255
    2612:	80 93 5d 05 	sts	0x055D, r24
}
    2616:	cf 91       	pop	r28
    2618:	df 91       	pop	r29
    261a:	08 95       	ret

0000261c <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    261c:	df 93       	push	r29
    261e:	cf 93       	push	r28
    2620:	00 d0       	rcall	.+0      	; 0x2622 <xTaskResumeAll+0x6>
    2622:	00 d0       	rcall	.+0      	; 0x2624 <xTaskResumeAll+0x8>
    2624:	cd b7       	in	r28, 0x3d	; 61
    2626:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2628:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	f8 94       	cli
    262e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2630:	80 91 5d 05 	lds	r24, 0x055D
    2634:	81 50       	subi	r24, 0x01	; 1
    2636:	80 93 5d 05 	sts	0x055D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    263a:	80 91 5d 05 	lds	r24, 0x055D
    263e:	88 23       	and	r24, r24
    2640:	09 f0       	breq	.+2      	; 0x2644 <xTaskResumeAll+0x28>
    2642:	6c c0       	rjmp	.+216    	; 0x271c <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2644:	80 91 57 05 	lds	r24, 0x0557
    2648:	88 23       	and	r24, r24
    264a:	09 f4       	brne	.+2      	; 0x264e <xTaskResumeAll+0x32>
    264c:	67 c0       	rjmp	.+206    	; 0x271c <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    264e:	19 82       	std	Y+1, r1	; 0x01
    2650:	41 c0       	rjmp	.+130    	; 0x26d4 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2652:	e0 91 ce 05 	lds	r30, 0x05CE
    2656:	f0 91 cf 05 	lds	r31, 0x05CF
    265a:	86 81       	ldd	r24, Z+6	; 0x06
    265c:	97 81       	ldd	r25, Z+7	; 0x07
    265e:	9c 83       	std	Y+4, r25	; 0x04
    2660:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2662:	8b 81       	ldd	r24, Y+3	; 0x03
    2664:	9c 81       	ldd	r25, Y+4	; 0x04
    2666:	0c 96       	adiw	r24, 0x0c	; 12
    2668:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    266c:	8b 81       	ldd	r24, Y+3	; 0x03
    266e:	9c 81       	ldd	r25, Y+4	; 0x04
    2670:	02 96       	adiw	r24, 0x02	; 2
    2672:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2676:	eb 81       	ldd	r30, Y+3	; 0x03
    2678:	fc 81       	ldd	r31, Y+4	; 0x04
    267a:	96 89       	ldd	r25, Z+22	; 0x16
    267c:	80 91 5b 05 	lds	r24, 0x055B
    2680:	89 17       	cp	r24, r25
    2682:	28 f4       	brcc	.+10     	; 0x268e <xTaskResumeAll+0x72>
    2684:	eb 81       	ldd	r30, Y+3	; 0x03
    2686:	fc 81       	ldd	r31, Y+4	; 0x04
    2688:	86 89       	ldd	r24, Z+22	; 0x16
    268a:	80 93 5b 05 	sts	0x055B, r24
    268e:	eb 81       	ldd	r30, Y+3	; 0x03
    2690:	fc 81       	ldd	r31, Y+4	; 0x04
    2692:	86 89       	ldd	r24, Z+22	; 0x16
    2694:	28 2f       	mov	r18, r24
    2696:	30 e0       	ldi	r19, 0x00	; 0
    2698:	c9 01       	movw	r24, r18
    269a:	88 0f       	add	r24, r24
    269c:	99 1f       	adc	r25, r25
    269e:	88 0f       	add	r24, r24
    26a0:	99 1f       	adc	r25, r25
    26a2:	88 0f       	add	r24, r24
    26a4:	99 1f       	adc	r25, r25
    26a6:	82 0f       	add	r24, r18
    26a8:	93 1f       	adc	r25, r19
    26aa:	8e 59       	subi	r24, 0x9E	; 158
    26ac:	9a 4f       	sbci	r25, 0xFA	; 250
    26ae:	2b 81       	ldd	r18, Y+3	; 0x03
    26b0:	3c 81       	ldd	r19, Y+4	; 0x04
    26b2:	2e 5f       	subi	r18, 0xFE	; 254
    26b4:	3f 4f       	sbci	r19, 0xFF	; 255
    26b6:	b9 01       	movw	r22, r18
    26b8:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26bc:	eb 81       	ldd	r30, Y+3	; 0x03
    26be:	fc 81       	ldd	r31, Y+4	; 0x04
    26c0:	96 89       	ldd	r25, Z+22	; 0x16
    26c2:	e0 91 54 05 	lds	r30, 0x0554
    26c6:	f0 91 55 05 	lds	r31, 0x0555
    26ca:	86 89       	ldd	r24, Z+22	; 0x16
    26cc:	98 17       	cp	r25, r24
    26ce:	10 f0       	brcs	.+4      	; 0x26d4 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    26d4:	80 91 c9 05 	lds	r24, 0x05C9
    26d8:	88 23       	and	r24, r24
    26da:	09 f0       	breq	.+2      	; 0x26de <xTaskResumeAll+0xc2>
    26dc:	ba cf       	rjmp	.-140    	; 0x2652 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    26de:	80 91 5e 05 	lds	r24, 0x055E
    26e2:	88 23       	and	r24, r24
    26e4:	71 f0       	breq	.+28     	; 0x2702 <xTaskResumeAll+0xe6>
    26e6:	07 c0       	rjmp	.+14     	; 0x26f6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    26e8:	0e 94 cd 13 	call	0x279a	; 0x279a <vTaskIncrementTick>
						--uxMissedTicks;
    26ec:	80 91 5e 05 	lds	r24, 0x055E
    26f0:	81 50       	subi	r24, 0x01	; 1
    26f2:	80 93 5e 05 	sts	0x055E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    26f6:	80 91 5e 05 	lds	r24, 0x055E
    26fa:	88 23       	and	r24, r24
    26fc:	a9 f7       	brne	.-22     	; 0x26e8 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    26fe:	81 e0       	ldi	r24, 0x01	; 1
    2700:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2702:	89 81       	ldd	r24, Y+1	; 0x01
    2704:	81 30       	cpi	r24, 0x01	; 1
    2706:	21 f0       	breq	.+8      	; 0x2710 <xTaskResumeAll+0xf4>
    2708:	80 91 5f 05 	lds	r24, 0x055F
    270c:	81 30       	cpi	r24, 0x01	; 1
    270e:	31 f4       	brne	.+12     	; 0x271c <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2710:	81 e0       	ldi	r24, 0x01	; 1
    2712:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2714:	10 92 5f 05 	sts	0x055F, r1
					portYIELD_WITHIN_API();
    2718:	0e 94 32 0b 	call	0x1664	; 0x1664 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2720:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2722:	0f 90       	pop	r0
    2724:	0f 90       	pop	r0
    2726:	0f 90       	pop	r0
    2728:	0f 90       	pop	r0
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	08 95       	ret

00002730 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2730:	df 93       	push	r29
    2732:	cf 93       	push	r28
    2734:	00 d0       	rcall	.+0      	; 0x2736 <xTaskGetTickCount+0x6>
    2736:	cd b7       	in	r28, 0x3d	; 61
    2738:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2740:	80 91 58 05 	lds	r24, 0x0558
    2744:	90 91 59 05 	lds	r25, 0x0559
    2748:	9a 83       	std	Y+2, r25	; 0x02
    274a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    274c:	0f 90       	pop	r0
    274e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2750:	89 81       	ldd	r24, Y+1	; 0x01
    2752:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2754:	0f 90       	pop	r0
    2756:	0f 90       	pop	r0
    2758:	cf 91       	pop	r28
    275a:	df 91       	pop	r29
    275c:	08 95       	ret

0000275e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    275e:	df 93       	push	r29
    2760:	cf 93       	push	r28
    2762:	00 d0       	rcall	.+0      	; 0x2764 <xTaskGetTickCountFromISR+0x6>
    2764:	0f 92       	push	r0
    2766:	cd b7       	in	r28, 0x3d	; 61
    2768:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    276a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    276c:	80 91 58 05 	lds	r24, 0x0558
    2770:	90 91 59 05 	lds	r25, 0x0559
    2774:	9b 83       	std	Y+3, r25	; 0x03
    2776:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2778:	8a 81       	ldd	r24, Y+2	; 0x02
    277a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    277c:	0f 90       	pop	r0
    277e:	0f 90       	pop	r0
    2780:	0f 90       	pop	r0
    2782:	cf 91       	pop	r28
    2784:	df 91       	pop	r29
    2786:	08 95       	ret

00002788 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2788:	df 93       	push	r29
    278a:	cf 93       	push	r28
    278c:	cd b7       	in	r28, 0x3d	; 61
    278e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2790:	80 91 57 05 	lds	r24, 0x0557
}
    2794:	cf 91       	pop	r28
    2796:	df 91       	pop	r29
    2798:	08 95       	ret

0000279a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    279a:	df 93       	push	r29
    279c:	cf 93       	push	r28
    279e:	00 d0       	rcall	.+0      	; 0x27a0 <vTaskIncrementTick+0x6>
    27a0:	00 d0       	rcall	.+0      	; 0x27a2 <vTaskIncrementTick+0x8>
    27a2:	00 d0       	rcall	.+0      	; 0x27a4 <vTaskIncrementTick+0xa>
    27a4:	cd b7       	in	r28, 0x3d	; 61
    27a6:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27a8:	80 91 5d 05 	lds	r24, 0x055D
    27ac:	88 23       	and	r24, r24
    27ae:	09 f0       	breq	.+2      	; 0x27b2 <vTaskIncrementTick+0x18>
    27b0:	bb c0       	rjmp	.+374    	; 0x2928 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    27b2:	80 91 58 05 	lds	r24, 0x0558
    27b6:	90 91 59 05 	lds	r25, 0x0559
    27ba:	01 96       	adiw	r24, 0x01	; 1
    27bc:	90 93 59 05 	sts	0x0559, r25
    27c0:	80 93 58 05 	sts	0x0558, r24
		if( xTickCount == ( portTickType ) 0U )
    27c4:	80 91 58 05 	lds	r24, 0x0558
    27c8:	90 91 59 05 	lds	r25, 0x0559
    27cc:	00 97       	sbiw	r24, 0x00	; 0
    27ce:	d1 f5       	brne	.+116    	; 0x2844 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    27d0:	80 91 c5 05 	lds	r24, 0x05C5
    27d4:	90 91 c6 05 	lds	r25, 0x05C6
    27d8:	9c 83       	std	Y+4, r25	; 0x04
    27da:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    27dc:	80 91 c7 05 	lds	r24, 0x05C7
    27e0:	90 91 c8 05 	lds	r25, 0x05C8
    27e4:	90 93 c6 05 	sts	0x05C6, r25
    27e8:	80 93 c5 05 	sts	0x05C5, r24
			pxOverflowDelayedTaskList = pxTemp;
    27ec:	8b 81       	ldd	r24, Y+3	; 0x03
    27ee:	9c 81       	ldd	r25, Y+4	; 0x04
    27f0:	90 93 c8 05 	sts	0x05C8, r25
    27f4:	80 93 c7 05 	sts	0x05C7, r24
			xNumOfOverflows++;
    27f8:	80 91 60 05 	lds	r24, 0x0560
    27fc:	8f 5f       	subi	r24, 0xFF	; 255
    27fe:	80 93 60 05 	sts	0x0560, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2802:	e0 91 c5 05 	lds	r30, 0x05C5
    2806:	f0 91 c6 05 	lds	r31, 0x05C6
    280a:	80 81       	ld	r24, Z
    280c:	88 23       	and	r24, r24
    280e:	39 f4       	brne	.+14     	; 0x281e <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2810:	8f ef       	ldi	r24, 0xFF	; 255
    2812:	9f ef       	ldi	r25, 0xFF	; 255
    2814:	90 93 66 00 	sts	0x0066, r25
    2818:	80 93 65 00 	sts	0x0065, r24
    281c:	13 c0       	rjmp	.+38     	; 0x2844 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    281e:	e0 91 c5 05 	lds	r30, 0x05C5
    2822:	f0 91 c6 05 	lds	r31, 0x05C6
    2826:	05 80       	ldd	r0, Z+5	; 0x05
    2828:	f6 81       	ldd	r31, Z+6	; 0x06
    282a:	e0 2d       	mov	r30, r0
    282c:	86 81       	ldd	r24, Z+6	; 0x06
    282e:	97 81       	ldd	r25, Z+7	; 0x07
    2830:	9e 83       	std	Y+6, r25	; 0x06
    2832:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2834:	ed 81       	ldd	r30, Y+5	; 0x05
    2836:	fe 81       	ldd	r31, Y+6	; 0x06
    2838:	82 81       	ldd	r24, Z+2	; 0x02
    283a:	93 81       	ldd	r25, Z+3	; 0x03
    283c:	90 93 66 00 	sts	0x0066, r25
    2840:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2844:	20 91 58 05 	lds	r18, 0x0558
    2848:	30 91 59 05 	lds	r19, 0x0559
    284c:	80 91 65 00 	lds	r24, 0x0065
    2850:	90 91 66 00 	lds	r25, 0x0066
    2854:	28 17       	cp	r18, r24
    2856:	39 07       	cpc	r19, r25
    2858:	08 f4       	brcc	.+2      	; 0x285c <vTaskIncrementTick+0xc2>
    285a:	6b c0       	rjmp	.+214    	; 0x2932 <vTaskIncrementTick+0x198>
    285c:	e0 91 c5 05 	lds	r30, 0x05C5
    2860:	f0 91 c6 05 	lds	r31, 0x05C6
    2864:	80 81       	ld	r24, Z
    2866:	88 23       	and	r24, r24
    2868:	39 f4       	brne	.+14     	; 0x2878 <vTaskIncrementTick+0xde>
    286a:	8f ef       	ldi	r24, 0xFF	; 255
    286c:	9f ef       	ldi	r25, 0xFF	; 255
    286e:	90 93 66 00 	sts	0x0066, r25
    2872:	80 93 65 00 	sts	0x0065, r24
    2876:	5d c0       	rjmp	.+186    	; 0x2932 <vTaskIncrementTick+0x198>
    2878:	e0 91 c5 05 	lds	r30, 0x05C5
    287c:	f0 91 c6 05 	lds	r31, 0x05C6
    2880:	05 80       	ldd	r0, Z+5	; 0x05
    2882:	f6 81       	ldd	r31, Z+6	; 0x06
    2884:	e0 2d       	mov	r30, r0
    2886:	86 81       	ldd	r24, Z+6	; 0x06
    2888:	97 81       	ldd	r25, Z+7	; 0x07
    288a:	9e 83       	std	Y+6, r25	; 0x06
    288c:	8d 83       	std	Y+5, r24	; 0x05
    288e:	ed 81       	ldd	r30, Y+5	; 0x05
    2890:	fe 81       	ldd	r31, Y+6	; 0x06
    2892:	82 81       	ldd	r24, Z+2	; 0x02
    2894:	93 81       	ldd	r25, Z+3	; 0x03
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	89 83       	std	Y+1, r24	; 0x01
    289a:	20 91 58 05 	lds	r18, 0x0558
    289e:	30 91 59 05 	lds	r19, 0x0559
    28a2:	89 81       	ldd	r24, Y+1	; 0x01
    28a4:	9a 81       	ldd	r25, Y+2	; 0x02
    28a6:	28 17       	cp	r18, r24
    28a8:	39 07       	cpc	r19, r25
    28aa:	38 f4       	brcc	.+14     	; 0x28ba <vTaskIncrementTick+0x120>
    28ac:	89 81       	ldd	r24, Y+1	; 0x01
    28ae:	9a 81       	ldd	r25, Y+2	; 0x02
    28b0:	90 93 66 00 	sts	0x0066, r25
    28b4:	80 93 65 00 	sts	0x0065, r24
    28b8:	3c c0       	rjmp	.+120    	; 0x2932 <vTaskIncrementTick+0x198>
    28ba:	8d 81       	ldd	r24, Y+5	; 0x05
    28bc:	9e 81       	ldd	r25, Y+6	; 0x06
    28be:	02 96       	adiw	r24, 0x02	; 2
    28c0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
    28c4:	ed 81       	ldd	r30, Y+5	; 0x05
    28c6:	fe 81       	ldd	r31, Y+6	; 0x06
    28c8:	84 89       	ldd	r24, Z+20	; 0x14
    28ca:	95 89       	ldd	r25, Z+21	; 0x15
    28cc:	00 97       	sbiw	r24, 0x00	; 0
    28ce:	29 f0       	breq	.+10     	; 0x28da <vTaskIncrementTick+0x140>
    28d0:	8d 81       	ldd	r24, Y+5	; 0x05
    28d2:	9e 81       	ldd	r25, Y+6	; 0x06
    28d4:	0c 96       	adiw	r24, 0x0c	; 12
    28d6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
    28da:	ed 81       	ldd	r30, Y+5	; 0x05
    28dc:	fe 81       	ldd	r31, Y+6	; 0x06
    28de:	96 89       	ldd	r25, Z+22	; 0x16
    28e0:	80 91 5b 05 	lds	r24, 0x055B
    28e4:	89 17       	cp	r24, r25
    28e6:	28 f4       	brcc	.+10     	; 0x28f2 <vTaskIncrementTick+0x158>
    28e8:	ed 81       	ldd	r30, Y+5	; 0x05
    28ea:	fe 81       	ldd	r31, Y+6	; 0x06
    28ec:	86 89       	ldd	r24, Z+22	; 0x16
    28ee:	80 93 5b 05 	sts	0x055B, r24
    28f2:	ed 81       	ldd	r30, Y+5	; 0x05
    28f4:	fe 81       	ldd	r31, Y+6	; 0x06
    28f6:	86 89       	ldd	r24, Z+22	; 0x16
    28f8:	28 2f       	mov	r18, r24
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	c9 01       	movw	r24, r18
    28fe:	88 0f       	add	r24, r24
    2900:	99 1f       	adc	r25, r25
    2902:	88 0f       	add	r24, r24
    2904:	99 1f       	adc	r25, r25
    2906:	88 0f       	add	r24, r24
    2908:	99 1f       	adc	r25, r25
    290a:	82 0f       	add	r24, r18
    290c:	93 1f       	adc	r25, r19
    290e:	ac 01       	movw	r20, r24
    2910:	4e 59       	subi	r20, 0x9E	; 158
    2912:	5a 4f       	sbci	r21, 0xFA	; 250
    2914:	8d 81       	ldd	r24, Y+5	; 0x05
    2916:	9e 81       	ldd	r25, Y+6	; 0x06
    2918:	9c 01       	movw	r18, r24
    291a:	2e 5f       	subi	r18, 0xFE	; 254
    291c:	3f 4f       	sbci	r19, 0xFF	; 255
    291e:	ca 01       	movw	r24, r20
    2920:	b9 01       	movw	r22, r18
    2922:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>
    2926:	9a cf       	rjmp	.-204    	; 0x285c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2928:	80 91 5e 05 	lds	r24, 0x055E
    292c:	8f 5f       	subi	r24, 0xFF	; 255
    292e:	80 93 5e 05 	sts	0x055E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2932:	26 96       	adiw	r28, 0x06	; 6
    2934:	0f b6       	in	r0, 0x3f	; 63
    2936:	f8 94       	cli
    2938:	de bf       	out	0x3e, r29	; 62
    293a:	0f be       	out	0x3f, r0	; 63
    293c:	cd bf       	out	0x3d, r28	; 61
    293e:	cf 91       	pop	r28
    2940:	df 91       	pop	r29
    2942:	08 95       	ret

00002944 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2944:	df 93       	push	r29
    2946:	cf 93       	push	r28
    2948:	00 d0       	rcall	.+0      	; 0x294a <vTaskSwitchContext+0x6>
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    294e:	80 91 5d 05 	lds	r24, 0x055D
    2952:	88 23       	and	r24, r24
    2954:	49 f0       	breq	.+18     	; 0x2968 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	80 93 5f 05 	sts	0x055F, r24
    295c:	54 c0       	rjmp	.+168    	; 0x2a06 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    295e:	80 91 5b 05 	lds	r24, 0x055B
    2962:	81 50       	subi	r24, 0x01	; 1
    2964:	80 93 5b 05 	sts	0x055B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2968:	80 91 5b 05 	lds	r24, 0x055B
    296c:	28 2f       	mov	r18, r24
    296e:	30 e0       	ldi	r19, 0x00	; 0
    2970:	c9 01       	movw	r24, r18
    2972:	88 0f       	add	r24, r24
    2974:	99 1f       	adc	r25, r25
    2976:	88 0f       	add	r24, r24
    2978:	99 1f       	adc	r25, r25
    297a:	88 0f       	add	r24, r24
    297c:	99 1f       	adc	r25, r25
    297e:	82 0f       	add	r24, r18
    2980:	93 1f       	adc	r25, r19
    2982:	fc 01       	movw	r30, r24
    2984:	ee 59       	subi	r30, 0x9E	; 158
    2986:	fa 4f       	sbci	r31, 0xFA	; 250
    2988:	80 81       	ld	r24, Z
    298a:	88 23       	and	r24, r24
    298c:	41 f3       	breq	.-48     	; 0x295e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    298e:	80 91 5b 05 	lds	r24, 0x055B
    2992:	28 2f       	mov	r18, r24
    2994:	30 e0       	ldi	r19, 0x00	; 0
    2996:	c9 01       	movw	r24, r18
    2998:	88 0f       	add	r24, r24
    299a:	99 1f       	adc	r25, r25
    299c:	88 0f       	add	r24, r24
    299e:	99 1f       	adc	r25, r25
    29a0:	88 0f       	add	r24, r24
    29a2:	99 1f       	adc	r25, r25
    29a4:	82 0f       	add	r24, r18
    29a6:	93 1f       	adc	r25, r19
    29a8:	8e 59       	subi	r24, 0x9E	; 158
    29aa:	9a 4f       	sbci	r25, 0xFA	; 250
    29ac:	9a 83       	std	Y+2, r25	; 0x02
    29ae:	89 83       	std	Y+1, r24	; 0x01
    29b0:	e9 81       	ldd	r30, Y+1	; 0x01
    29b2:	fa 81       	ldd	r31, Y+2	; 0x02
    29b4:	01 80       	ldd	r0, Z+1	; 0x01
    29b6:	f2 81       	ldd	r31, Z+2	; 0x02
    29b8:	e0 2d       	mov	r30, r0
    29ba:	82 81       	ldd	r24, Z+2	; 0x02
    29bc:	93 81       	ldd	r25, Z+3	; 0x03
    29be:	e9 81       	ldd	r30, Y+1	; 0x01
    29c0:	fa 81       	ldd	r31, Y+2	; 0x02
    29c2:	92 83       	std	Z+2, r25	; 0x02
    29c4:	81 83       	std	Z+1, r24	; 0x01
    29c6:	e9 81       	ldd	r30, Y+1	; 0x01
    29c8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ca:	21 81       	ldd	r18, Z+1	; 0x01
    29cc:	32 81       	ldd	r19, Z+2	; 0x02
    29ce:	89 81       	ldd	r24, Y+1	; 0x01
    29d0:	9a 81       	ldd	r25, Y+2	; 0x02
    29d2:	03 96       	adiw	r24, 0x03	; 3
    29d4:	28 17       	cp	r18, r24
    29d6:	39 07       	cpc	r19, r25
    29d8:	59 f4       	brne	.+22     	; 0x29f0 <vTaskSwitchContext+0xac>
    29da:	e9 81       	ldd	r30, Y+1	; 0x01
    29dc:	fa 81       	ldd	r31, Y+2	; 0x02
    29de:	01 80       	ldd	r0, Z+1	; 0x01
    29e0:	f2 81       	ldd	r31, Z+2	; 0x02
    29e2:	e0 2d       	mov	r30, r0
    29e4:	82 81       	ldd	r24, Z+2	; 0x02
    29e6:	93 81       	ldd	r25, Z+3	; 0x03
    29e8:	e9 81       	ldd	r30, Y+1	; 0x01
    29ea:	fa 81       	ldd	r31, Y+2	; 0x02
    29ec:	92 83       	std	Z+2, r25	; 0x02
    29ee:	81 83       	std	Z+1, r24	; 0x01
    29f0:	e9 81       	ldd	r30, Y+1	; 0x01
    29f2:	fa 81       	ldd	r31, Y+2	; 0x02
    29f4:	01 80       	ldd	r0, Z+1	; 0x01
    29f6:	f2 81       	ldd	r31, Z+2	; 0x02
    29f8:	e0 2d       	mov	r30, r0
    29fa:	86 81       	ldd	r24, Z+6	; 0x06
    29fc:	97 81       	ldd	r25, Z+7	; 0x07
    29fe:	90 93 55 05 	sts	0x0555, r25
    2a02:	80 93 54 05 	sts	0x0554, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2a06:	0f 90       	pop	r0
    2a08:	0f 90       	pop	r0
    2a0a:	cf 91       	pop	r28
    2a0c:	df 91       	pop	r29
    2a0e:	08 95       	ret

00002a10 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2a10:	df 93       	push	r29
    2a12:	cf 93       	push	r28
    2a14:	00 d0       	rcall	.+0      	; 0x2a16 <vTaskPlaceOnEventList+0x6>
    2a16:	00 d0       	rcall	.+0      	; 0x2a18 <vTaskPlaceOnEventList+0x8>
    2a18:	00 d0       	rcall	.+0      	; 0x2a1a <vTaskPlaceOnEventList+0xa>
    2a1a:	cd b7       	in	r28, 0x3d	; 61
    2a1c:	de b7       	in	r29, 0x3e	; 62
    2a1e:	9c 83       	std	Y+4, r25	; 0x04
    2a20:	8b 83       	std	Y+3, r24	; 0x03
    2a22:	7e 83       	std	Y+6, r23	; 0x06
    2a24:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2a26:	4b 81       	ldd	r20, Y+3	; 0x03
    2a28:	5c 81       	ldd	r21, Y+4	; 0x04
    2a2a:	80 91 54 05 	lds	r24, 0x0554
    2a2e:	90 91 55 05 	lds	r25, 0x0555
    2a32:	9c 01       	movw	r18, r24
    2a34:	24 5f       	subi	r18, 0xF4	; 244
    2a36:	3f 4f       	sbci	r19, 0xFF	; 255
    2a38:	ca 01       	movw	r24, r20
    2a3a:	b9 01       	movw	r22, r18
    2a3c:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a40:	80 91 54 05 	lds	r24, 0x0554
    2a44:	90 91 55 05 	lds	r25, 0x0555
    2a48:	02 96       	adiw	r24, 0x02	; 2
    2a4a:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2a4e:	20 91 58 05 	lds	r18, 0x0558
    2a52:	30 91 59 05 	lds	r19, 0x0559
    2a56:	8d 81       	ldd	r24, Y+5	; 0x05
    2a58:	9e 81       	ldd	r25, Y+6	; 0x06
    2a5a:	82 0f       	add	r24, r18
    2a5c:	93 1f       	adc	r25, r19
    2a5e:	9a 83       	std	Y+2, r25	; 0x02
    2a60:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2a62:	89 81       	ldd	r24, Y+1	; 0x01
    2a64:	9a 81       	ldd	r25, Y+2	; 0x02
    2a66:	0e 94 02 17 	call	0x2e04	; 0x2e04 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2a6a:	26 96       	adiw	r28, 0x06	; 6
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	cd bf       	out	0x3d, r28	; 61
    2a76:	cf 91       	pop	r28
    2a78:	df 91       	pop	r29
    2a7a:	08 95       	ret

00002a7c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2a7c:	df 93       	push	r29
    2a7e:	cf 93       	push	r28
    2a80:	00 d0       	rcall	.+0      	; 0x2a82 <xTaskRemoveFromEventList+0x6>
    2a82:	00 d0       	rcall	.+0      	; 0x2a84 <xTaskRemoveFromEventList+0x8>
    2a84:	0f 92       	push	r0
    2a86:	cd b7       	in	r28, 0x3d	; 61
    2a88:	de b7       	in	r29, 0x3e	; 62
    2a8a:	9d 83       	std	Y+5, r25	; 0x05
    2a8c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2a8e:	ec 81       	ldd	r30, Y+4	; 0x04
    2a90:	fd 81       	ldd	r31, Y+5	; 0x05
    2a92:	05 80       	ldd	r0, Z+5	; 0x05
    2a94:	f6 81       	ldd	r31, Z+6	; 0x06
    2a96:	e0 2d       	mov	r30, r0
    2a98:	86 81       	ldd	r24, Z+6	; 0x06
    2a9a:	97 81       	ldd	r25, Z+7	; 0x07
    2a9c:	9b 83       	std	Y+3, r25	; 0x03
    2a9e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    2aa2:	9b 81       	ldd	r25, Y+3	; 0x03
    2aa4:	0c 96       	adiw	r24, 0x0c	; 12
    2aa6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2aaa:	80 91 5d 05 	lds	r24, 0x055D
    2aae:	88 23       	and	r24, r24
    2ab0:	61 f5       	brne	.+88     	; 0x2b0a <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ab6:	02 96       	adiw	r24, 0x02	; 2
    2ab8:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2abc:	ea 81       	ldd	r30, Y+2	; 0x02
    2abe:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac0:	96 89       	ldd	r25, Z+22	; 0x16
    2ac2:	80 91 5b 05 	lds	r24, 0x055B
    2ac6:	89 17       	cp	r24, r25
    2ac8:	28 f4       	brcc	.+10     	; 0x2ad4 <xTaskRemoveFromEventList+0x58>
    2aca:	ea 81       	ldd	r30, Y+2	; 0x02
    2acc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ace:	86 89       	ldd	r24, Z+22	; 0x16
    2ad0:	80 93 5b 05 	sts	0x055B, r24
    2ad4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ad6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ad8:	86 89       	ldd	r24, Z+22	; 0x16
    2ada:	28 2f       	mov	r18, r24
    2adc:	30 e0       	ldi	r19, 0x00	; 0
    2ade:	c9 01       	movw	r24, r18
    2ae0:	88 0f       	add	r24, r24
    2ae2:	99 1f       	adc	r25, r25
    2ae4:	88 0f       	add	r24, r24
    2ae6:	99 1f       	adc	r25, r25
    2ae8:	88 0f       	add	r24, r24
    2aea:	99 1f       	adc	r25, r25
    2aec:	82 0f       	add	r24, r18
    2aee:	93 1f       	adc	r25, r19
    2af0:	ac 01       	movw	r20, r24
    2af2:	4e 59       	subi	r20, 0x9E	; 158
    2af4:	5a 4f       	sbci	r21, 0xFA	; 250
    2af6:	8a 81       	ldd	r24, Y+2	; 0x02
    2af8:	9b 81       	ldd	r25, Y+3	; 0x03
    2afa:	9c 01       	movw	r18, r24
    2afc:	2e 5f       	subi	r18, 0xFE	; 254
    2afe:	3f 4f       	sbci	r19, 0xFF	; 255
    2b00:	ca 01       	movw	r24, r20
    2b02:	b9 01       	movw	r22, r18
    2b04:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>
    2b08:	0a c0       	rjmp	.+20     	; 0x2b1e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0e:	9c 01       	movw	r18, r24
    2b10:	24 5f       	subi	r18, 0xF4	; 244
    2b12:	3f 4f       	sbci	r19, 0xFF	; 255
    2b14:	89 ec       	ldi	r24, 0xC9	; 201
    2b16:	95 e0       	ldi	r25, 0x05	; 5
    2b18:	b9 01       	movw	r22, r18
    2b1a:	0e 94 ba 07 	call	0xf74	; 0xf74 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b20:	fb 81       	ldd	r31, Y+3	; 0x03
    2b22:	96 89       	ldd	r25, Z+22	; 0x16
    2b24:	e0 91 54 05 	lds	r30, 0x0554
    2b28:	f0 91 55 05 	lds	r31, 0x0555
    2b2c:	86 89       	ldd	r24, Z+22	; 0x16
    2b2e:	98 17       	cp	r25, r24
    2b30:	18 f0       	brcs	.+6      	; 0x2b38 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	89 83       	std	Y+1, r24	; 0x01
    2b36:	01 c0       	rjmp	.+2      	; 0x2b3a <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2b38:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b3a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b3c:	0f 90       	pop	r0
    2b3e:	0f 90       	pop	r0
    2b40:	0f 90       	pop	r0
    2b42:	0f 90       	pop	r0
    2b44:	0f 90       	pop	r0
    2b46:	cf 91       	pop	r28
    2b48:	df 91       	pop	r29
    2b4a:	08 95       	ret

00002b4c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2b4c:	df 93       	push	r29
    2b4e:	cf 93       	push	r28
    2b50:	00 d0       	rcall	.+0      	; 0x2b52 <vTaskSetTimeOutState+0x6>
    2b52:	cd b7       	in	r28, 0x3d	; 61
    2b54:	de b7       	in	r29, 0x3e	; 62
    2b56:	9a 83       	std	Y+2, r25	; 0x02
    2b58:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b5a:	80 91 60 05 	lds	r24, 0x0560
    2b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b60:	fa 81       	ldd	r31, Y+2	; 0x02
    2b62:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2b64:	80 91 58 05 	lds	r24, 0x0558
    2b68:	90 91 59 05 	lds	r25, 0x0559
    2b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b70:	92 83       	std	Z+2, r25	; 0x02
    2b72:	81 83       	std	Z+1, r24	; 0x01
}
    2b74:	0f 90       	pop	r0
    2b76:	0f 90       	pop	r0
    2b78:	cf 91       	pop	r28
    2b7a:	df 91       	pop	r29
    2b7c:	08 95       	ret

00002b7e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2b7e:	df 93       	push	r29
    2b80:	cf 93       	push	r28
    2b82:	00 d0       	rcall	.+0      	; 0x2b84 <xTaskCheckForTimeOut+0x6>
    2b84:	00 d0       	rcall	.+0      	; 0x2b86 <xTaskCheckForTimeOut+0x8>
    2b86:	0f 92       	push	r0
    2b88:	cd b7       	in	r28, 0x3d	; 61
    2b8a:	de b7       	in	r29, 0x3e	; 62
    2b8c:	9b 83       	std	Y+3, r25	; 0x03
    2b8e:	8a 83       	std	Y+2, r24	; 0x02
    2b90:	7d 83       	std	Y+5, r23	; 0x05
    2b92:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2b94:	0f b6       	in	r0, 0x3f	; 63
    2b96:	f8 94       	cli
    2b98:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2b9a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b9c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b9e:	90 81       	ld	r25, Z
    2ba0:	80 91 60 05 	lds	r24, 0x0560
    2ba4:	98 17       	cp	r25, r24
    2ba6:	71 f0       	breq	.+28     	; 0x2bc4 <xTaskCheckForTimeOut+0x46>
    2ba8:	ea 81       	ldd	r30, Y+2	; 0x02
    2baa:	fb 81       	ldd	r31, Y+3	; 0x03
    2bac:	21 81       	ldd	r18, Z+1	; 0x01
    2bae:	32 81       	ldd	r19, Z+2	; 0x02
    2bb0:	80 91 58 05 	lds	r24, 0x0558
    2bb4:	90 91 59 05 	lds	r25, 0x0559
    2bb8:	82 17       	cp	r24, r18
    2bba:	93 07       	cpc	r25, r19
    2bbc:	18 f0       	brcs	.+6      	; 0x2bc4 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	89 83       	std	Y+1, r24	; 0x01
    2bc2:	2f c0       	rjmp	.+94     	; 0x2c22 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2bc4:	20 91 58 05 	lds	r18, 0x0558
    2bc8:	30 91 59 05 	lds	r19, 0x0559
    2bcc:	ea 81       	ldd	r30, Y+2	; 0x02
    2bce:	fb 81       	ldd	r31, Y+3	; 0x03
    2bd0:	81 81       	ldd	r24, Z+1	; 0x01
    2bd2:	92 81       	ldd	r25, Z+2	; 0x02
    2bd4:	28 1b       	sub	r18, r24
    2bd6:	39 0b       	sbc	r19, r25
    2bd8:	ec 81       	ldd	r30, Y+4	; 0x04
    2bda:	fd 81       	ldd	r31, Y+5	; 0x05
    2bdc:	80 81       	ld	r24, Z
    2bde:	91 81       	ldd	r25, Z+1	; 0x01
    2be0:	28 17       	cp	r18, r24
    2be2:	39 07       	cpc	r19, r25
    2be4:	e0 f4       	brcc	.+56     	; 0x2c1e <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2be6:	ec 81       	ldd	r30, Y+4	; 0x04
    2be8:	fd 81       	ldd	r31, Y+5	; 0x05
    2bea:	40 81       	ld	r20, Z
    2bec:	51 81       	ldd	r21, Z+1	; 0x01
    2bee:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf2:	21 81       	ldd	r18, Z+1	; 0x01
    2bf4:	32 81       	ldd	r19, Z+2	; 0x02
    2bf6:	80 91 58 05 	lds	r24, 0x0558
    2bfa:	90 91 59 05 	lds	r25, 0x0559
    2bfe:	b9 01       	movw	r22, r18
    2c00:	68 1b       	sub	r22, r24
    2c02:	79 0b       	sbc	r23, r25
    2c04:	cb 01       	movw	r24, r22
    2c06:	84 0f       	add	r24, r20
    2c08:	95 1f       	adc	r25, r21
    2c0a:	ec 81       	ldd	r30, Y+4	; 0x04
    2c0c:	fd 81       	ldd	r31, Y+5	; 0x05
    2c0e:	91 83       	std	Z+1, r25	; 0x01
    2c10:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2c12:	8a 81       	ldd	r24, Y+2	; 0x02
    2c14:	9b 81       	ldd	r25, Y+3	; 0x03
    2c16:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c1a:	19 82       	std	Y+1, r1	; 0x01
    2c1c:	02 c0       	rjmp	.+4      	; 0x2c22 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
    2c20:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2c22:	0f 90       	pop	r0
    2c24:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c26:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c28:	0f 90       	pop	r0
    2c2a:	0f 90       	pop	r0
    2c2c:	0f 90       	pop	r0
    2c2e:	0f 90       	pop	r0
    2c30:	0f 90       	pop	r0
    2c32:	cf 91       	pop	r28
    2c34:	df 91       	pop	r29
    2c36:	08 95       	ret

00002c38 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2c38:	df 93       	push	r29
    2c3a:	cf 93       	push	r28
    2c3c:	cd b7       	in	r28, 0x3d	; 61
    2c3e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2c40:	81 e0       	ldi	r24, 0x01	; 1
    2c42:	80 93 5f 05 	sts	0x055F, r24
}
    2c46:	cf 91       	pop	r28
    2c48:	df 91       	pop	r29
    2c4a:	08 95       	ret

00002c4c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2c4c:	df 93       	push	r29
    2c4e:	cf 93       	push	r28
    2c50:	00 d0       	rcall	.+0      	; 0x2c52 <prvIdleTask+0x6>
    2c52:	cd b7       	in	r28, 0x3d	; 61
    2c54:	de b7       	in	r29, 0x3e	; 62
    2c56:	9a 83       	std	Y+2, r25	; 0x02
    2c58:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2c5a:	0e 94 c4 16 	call	0x2d88	; 0x2d88 <prvCheckTasksWaitingTermination>
    2c5e:	fd cf       	rjmp	.-6      	; 0x2c5a <prvIdleTask+0xe>

00002c60 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2c60:	0f 93       	push	r16
    2c62:	1f 93       	push	r17
    2c64:	df 93       	push	r29
    2c66:	cf 93       	push	r28
    2c68:	cd b7       	in	r28, 0x3d	; 61
    2c6a:	de b7       	in	r29, 0x3e	; 62
    2c6c:	29 97       	sbiw	r28, 0x09	; 9
    2c6e:	0f b6       	in	r0, 0x3f	; 63
    2c70:	f8 94       	cli
    2c72:	de bf       	out	0x3e, r29	; 62
    2c74:	0f be       	out	0x3f, r0	; 63
    2c76:	cd bf       	out	0x3d, r28	; 61
    2c78:	9a 83       	std	Y+2, r25	; 0x02
    2c7a:	89 83       	std	Y+1, r24	; 0x01
    2c7c:	7c 83       	std	Y+4, r23	; 0x04
    2c7e:	6b 83       	std	Y+3, r22	; 0x03
    2c80:	4d 83       	std	Y+5, r20	; 0x05
    2c82:	3f 83       	std	Y+7, r19	; 0x07
    2c84:	2e 83       	std	Y+6, r18	; 0x06
    2c86:	19 87       	std	Y+9, r17	; 0x09
    2c88:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2c8a:	89 81       	ldd	r24, Y+1	; 0x01
    2c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8e:	49 96       	adiw	r24, 0x19	; 25
    2c90:	2b 81       	ldd	r18, Y+3	; 0x03
    2c92:	3c 81       	ldd	r19, Y+4	; 0x04
    2c94:	b9 01       	movw	r22, r18
    2c96:	48 e0       	ldi	r20, 0x08	; 8
    2c98:	50 e0       	ldi	r21, 0x00	; 0
    2c9a:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca2:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2ca4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ca6:	89 30       	cpi	r24, 0x09	; 9
    2ca8:	10 f0       	brcs	.+4      	; 0x2cae <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2caa:	88 e0       	ldi	r24, 0x08	; 8
    2cac:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2cae:	e9 81       	ldd	r30, Y+1	; 0x01
    2cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cb2:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb4:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2cb6:	89 81       	ldd	r24, Y+1	; 0x01
    2cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2cba:	02 96       	adiw	r24, 0x02	; 2
    2cbc:	0e 94 aa 07 	call	0xf54	; 0xf54 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2cc0:	89 81       	ldd	r24, Y+1	; 0x01
    2cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc4:	0c 96       	adiw	r24, 0x0c	; 12
    2cc6:	0e 94 aa 07 	call	0xf54	; 0xf54 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2cca:	e9 81       	ldd	r30, Y+1	; 0x01
    2ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cce:	89 81       	ldd	r24, Y+1	; 0x01
    2cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd2:	91 87       	std	Z+9, r25	; 0x09
    2cd4:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2cd6:	8d 81       	ldd	r24, Y+5	; 0x05
    2cd8:	28 2f       	mov	r18, r24
    2cda:	30 e0       	ldi	r19, 0x00	; 0
    2cdc:	89 e0       	ldi	r24, 0x09	; 9
    2cde:	90 e0       	ldi	r25, 0x00	; 0
    2ce0:	82 1b       	sub	r24, r18
    2ce2:	93 0b       	sbc	r25, r19
    2ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce8:	95 87       	std	Z+13, r25	; 0x0d
    2cea:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2cec:	e9 81       	ldd	r30, Y+1	; 0x01
    2cee:	fa 81       	ldd	r31, Y+2	; 0x02
    2cf0:	89 81       	ldd	r24, Y+1	; 0x01
    2cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf4:	93 8b       	std	Z+19, r25	; 0x13
    2cf6:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2cf8:	29 96       	adiw	r28, 0x09	; 9
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	de bf       	out	0x3e, r29	; 62
    2d00:	0f be       	out	0x3f, r0	; 63
    2d02:	cd bf       	out	0x3d, r28	; 61
    2d04:	cf 91       	pop	r28
    2d06:	df 91       	pop	r29
    2d08:	1f 91       	pop	r17
    2d0a:	0f 91       	pop	r16
    2d0c:	08 95       	ret

00002d0e <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2d0e:	df 93       	push	r29
    2d10:	cf 93       	push	r28
    2d12:	0f 92       	push	r0
    2d14:	cd b7       	in	r28, 0x3d	; 61
    2d16:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2d18:	19 82       	std	Y+1, r1	; 0x01
    2d1a:	13 c0       	rjmp	.+38     	; 0x2d42 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2d1c:	89 81       	ldd	r24, Y+1	; 0x01
    2d1e:	28 2f       	mov	r18, r24
    2d20:	30 e0       	ldi	r19, 0x00	; 0
    2d22:	c9 01       	movw	r24, r18
    2d24:	88 0f       	add	r24, r24
    2d26:	99 1f       	adc	r25, r25
    2d28:	88 0f       	add	r24, r24
    2d2a:	99 1f       	adc	r25, r25
    2d2c:	88 0f       	add	r24, r24
    2d2e:	99 1f       	adc	r25, r25
    2d30:	82 0f       	add	r24, r18
    2d32:	93 1f       	adc	r25, r19
    2d34:	8e 59       	subi	r24, 0x9E	; 158
    2d36:	9a 4f       	sbci	r25, 0xFA	; 250
    2d38:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2d3c:	89 81       	ldd	r24, Y+1	; 0x01
    2d3e:	8f 5f       	subi	r24, 0xFF	; 255
    2d40:	89 83       	std	Y+1, r24	; 0x01
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	89 30       	cpi	r24, 0x09	; 9
    2d46:	50 f3       	brcs	.-44     	; 0x2d1c <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2d48:	83 eb       	ldi	r24, 0xB3	; 179
    2d4a:	95 e0       	ldi	r25, 0x05	; 5
    2d4c:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2d50:	8c eb       	ldi	r24, 0xBC	; 188
    2d52:	95 e0       	ldi	r25, 0x05	; 5
    2d54:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2d58:	89 ec       	ldi	r24, 0xC9	; 201
    2d5a:	95 e0       	ldi	r25, 0x05	; 5
    2d5c:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2d60:	82 ed       	ldi	r24, 0xD2	; 210
    2d62:	95 e0       	ldi	r25, 0x05	; 5
    2d64:	0e 94 80 07 	call	0xf00	; 0xf00 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2d68:	83 eb       	ldi	r24, 0xB3	; 179
    2d6a:	95 e0       	ldi	r25, 0x05	; 5
    2d6c:	90 93 c6 05 	sts	0x05C6, r25
    2d70:	80 93 c5 05 	sts	0x05C5, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2d74:	8c eb       	ldi	r24, 0xBC	; 188
    2d76:	95 e0       	ldi	r25, 0x05	; 5
    2d78:	90 93 c8 05 	sts	0x05C8, r25
    2d7c:	80 93 c7 05 	sts	0x05C7, r24
}
    2d80:	0f 90       	pop	r0
    2d82:	cf 91       	pop	r28
    2d84:	df 91       	pop	r29
    2d86:	08 95       	ret

00002d88 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2d88:	df 93       	push	r29
    2d8a:	cf 93       	push	r28
    2d8c:	00 d0       	rcall	.+0      	; 0x2d8e <prvCheckTasksWaitingTermination+0x6>
    2d8e:	0f 92       	push	r0
    2d90:	cd b7       	in	r28, 0x3d	; 61
    2d92:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2d94:	80 91 56 05 	lds	r24, 0x0556
    2d98:	88 23       	and	r24, r24
    2d9a:	71 f1       	breq	.+92     	; 0x2df8 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2d9c:	0e 94 02 13 	call	0x2604	; 0x2604 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2da0:	80 91 d2 05 	lds	r24, 0x05D2
    2da4:	1b 82       	std	Y+3, r1	; 0x03
    2da6:	88 23       	and	r24, r24
    2da8:	11 f4       	brne	.+4      	; 0x2dae <prvCheckTasksWaitingTermination+0x26>
    2daa:	81 e0       	ldi	r24, 0x01	; 1
    2dac:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2dae:	0e 94 0e 13 	call	0x261c	; 0x261c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2db2:	8b 81       	ldd	r24, Y+3	; 0x03
    2db4:	88 23       	and	r24, r24
    2db6:	01 f5       	brne	.+64     	; 0x2df8 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2db8:	0f b6       	in	r0, 0x3f	; 63
    2dba:	f8 94       	cli
    2dbc:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2dbe:	e0 91 d7 05 	lds	r30, 0x05D7
    2dc2:	f0 91 d8 05 	lds	r31, 0x05D8
    2dc6:	86 81       	ldd	r24, Z+6	; 0x06
    2dc8:	97 81       	ldd	r25, Z+7	; 0x07
    2dca:	9a 83       	std	Y+2, r25	; 0x02
    2dcc:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd2:	02 96       	adiw	r24, 0x02	; 2
    2dd4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vListRemove>
					--uxCurrentNumberOfTasks;
    2dd8:	80 91 57 05 	lds	r24, 0x0557
    2ddc:	81 50       	subi	r24, 0x01	; 1
    2dde:	80 93 57 05 	sts	0x0557, r24
					--uxTasksDeleted;
    2de2:	80 91 56 05 	lds	r24, 0x0556
    2de6:	81 50       	subi	r24, 0x01	; 1
    2de8:	80 93 56 05 	sts	0x0556, r24
				}
				taskEXIT_CRITICAL();
    2dec:	0f 90       	pop	r0
    2dee:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2df0:	89 81       	ldd	r24, Y+1	; 0x01
    2df2:	9a 81       	ldd	r25, Y+2	; 0x02
    2df4:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2df8:	0f 90       	pop	r0
    2dfa:	0f 90       	pop	r0
    2dfc:	0f 90       	pop	r0
    2dfe:	cf 91       	pop	r28
    2e00:	df 91       	pop	r29
    2e02:	08 95       	ret

00002e04 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2e04:	df 93       	push	r29
    2e06:	cf 93       	push	r28
    2e08:	00 d0       	rcall	.+0      	; 0x2e0a <prvAddCurrentTaskToDelayedList+0x6>
    2e0a:	cd b7       	in	r28, 0x3d	; 61
    2e0c:	de b7       	in	r29, 0x3e	; 62
    2e0e:	9a 83       	std	Y+2, r25	; 0x02
    2e10:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2e12:	e0 91 54 05 	lds	r30, 0x0554
    2e16:	f0 91 55 05 	lds	r31, 0x0555
    2e1a:	89 81       	ldd	r24, Y+1	; 0x01
    2e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e1e:	93 83       	std	Z+3, r25	; 0x03
    2e20:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2e22:	20 91 58 05 	lds	r18, 0x0558
    2e26:	30 91 59 05 	lds	r19, 0x0559
    2e2a:	89 81       	ldd	r24, Y+1	; 0x01
    2e2c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e2e:	82 17       	cp	r24, r18
    2e30:	93 07       	cpc	r25, r19
    2e32:	70 f4       	brcc	.+28     	; 0x2e50 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e34:	80 91 c7 05 	lds	r24, 0x05C7
    2e38:	90 91 c8 05 	lds	r25, 0x05C8
    2e3c:	20 91 54 05 	lds	r18, 0x0554
    2e40:	30 91 55 05 	lds	r19, 0x0555
    2e44:	2e 5f       	subi	r18, 0xFE	; 254
    2e46:	3f 4f       	sbci	r19, 0xFF	; 255
    2e48:	b9 01       	movw	r22, r18
    2e4a:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>
    2e4e:	1e c0       	rjmp	.+60     	; 0x2e8c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e50:	40 91 c5 05 	lds	r20, 0x05C5
    2e54:	50 91 c6 05 	lds	r21, 0x05C6
    2e58:	80 91 54 05 	lds	r24, 0x0554
    2e5c:	90 91 55 05 	lds	r25, 0x0555
    2e60:	9c 01       	movw	r18, r24
    2e62:	2e 5f       	subi	r18, 0xFE	; 254
    2e64:	3f 4f       	sbci	r19, 0xFF	; 255
    2e66:	ca 01       	movw	r24, r20
    2e68:	b9 01       	movw	r22, r18
    2e6a:	0e 94 06 08 	call	0x100c	; 0x100c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2e6e:	20 91 65 00 	lds	r18, 0x0065
    2e72:	30 91 66 00 	lds	r19, 0x0066
    2e76:	89 81       	ldd	r24, Y+1	; 0x01
    2e78:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7a:	82 17       	cp	r24, r18
    2e7c:	93 07       	cpc	r25, r19
    2e7e:	30 f4       	brcc	.+12     	; 0x2e8c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2e80:	89 81       	ldd	r24, Y+1	; 0x01
    2e82:	9a 81       	ldd	r25, Y+2	; 0x02
    2e84:	90 93 66 00 	sts	0x0066, r25
    2e88:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    2e8c:	0f 90       	pop	r0
    2e8e:	0f 90       	pop	r0
    2e90:	cf 91       	pop	r28
    2e92:	df 91       	pop	r29
    2e94:	08 95       	ret

00002e96 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2e96:	df 93       	push	r29
    2e98:	cf 93       	push	r28
    2e9a:	cd b7       	in	r28, 0x3d	; 61
    2e9c:	de b7       	in	r29, 0x3e	; 62
    2e9e:	28 97       	sbiw	r28, 0x08	; 8
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	de bf       	out	0x3e, r29	; 62
    2ea6:	0f be       	out	0x3f, r0	; 63
    2ea8:	cd bf       	out	0x3d, r28	; 61
    2eaa:	9c 83       	std	Y+4, r25	; 0x04
    2eac:	8b 83       	std	Y+3, r24	; 0x03
    2eae:	7e 83       	std	Y+6, r23	; 0x06
    2eb0:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2eb2:	81 e2       	ldi	r24, 0x21	; 33
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	0e 94 14 07 	call	0xe28	; 0xe28 <pvPortMalloc>
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2ebe:	89 81       	ldd	r24, Y+1	; 0x01
    2ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec2:	00 97       	sbiw	r24, 0x00	; 0
    2ec4:	69 f1       	breq	.+90     	; 0x2f20 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2ec6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eca:	00 97       	sbiw	r24, 0x00	; 0
    2ecc:	39 f4       	brne	.+14     	; 0x2edc <prvAllocateTCBAndStack+0x46>
    2ece:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed2:	0e 94 14 07 	call	0xe28	; 0xe28 <pvPortMalloc>
    2ed6:	98 87       	std	Y+8, r25	; 0x08
    2ed8:	8f 83       	std	Y+7, r24	; 0x07
    2eda:	04 c0       	rjmp	.+8      	; 0x2ee4 <prvAllocateTCBAndStack+0x4e>
    2edc:	8d 81       	ldd	r24, Y+5	; 0x05
    2ede:	9e 81       	ldd	r25, Y+6	; 0x06
    2ee0:	98 87       	std	Y+8, r25	; 0x08
    2ee2:	8f 83       	std	Y+7, r24	; 0x07
    2ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ee8:	8f 81       	ldd	r24, Y+7	; 0x07
    2eea:	98 85       	ldd	r25, Y+8	; 0x08
    2eec:	90 8f       	std	Z+24, r25	; 0x18
    2eee:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef4:	87 89       	ldd	r24, Z+23	; 0x17
    2ef6:	90 8d       	ldd	r25, Z+24	; 0x18
    2ef8:	00 97       	sbiw	r24, 0x00	; 0
    2efa:	39 f4       	brne	.+14     	; 0x2f0a <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2efc:	89 81       	ldd	r24, Y+1	; 0x01
    2efe:	9a 81       	ldd	r25, Y+2	; 0x02
    2f00:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
			pxNewTCB = NULL;
    2f04:	1a 82       	std	Y+2, r1	; 0x02
    2f06:	19 82       	std	Y+1, r1	; 0x01
    2f08:	0b c0       	rjmp	.+22     	; 0x2f20 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0e:	87 89       	ldd	r24, Z+23	; 0x17
    2f10:	90 8d       	ldd	r25, Z+24	; 0x18
    2f12:	2b 81       	ldd	r18, Y+3	; 0x03
    2f14:	3c 81       	ldd	r19, Y+4	; 0x04
    2f16:	65 ea       	ldi	r22, 0xA5	; 165
    2f18:	70 e0       	ldi	r23, 0x00	; 0
    2f1a:	a9 01       	movw	r20, r18
    2f1c:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <memset>
		}
	}

	return pxNewTCB;
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f24:	28 96       	adiw	r28, 0x08	; 8
    2f26:	0f b6       	in	r0, 0x3f	; 63
    2f28:	f8 94       	cli
    2f2a:	de bf       	out	0x3e, r29	; 62
    2f2c:	0f be       	out	0x3f, r0	; 63
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	cf 91       	pop	r28
    2f32:	df 91       	pop	r29
    2f34:	08 95       	ret

00002f36 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2f36:	df 93       	push	r29
    2f38:	cf 93       	push	r28
    2f3a:	00 d0       	rcall	.+0      	; 0x2f3c <prvDeleteTCB+0x6>
    2f3c:	cd b7       	in	r28, 0x3d	; 61
    2f3e:	de b7       	in	r29, 0x3e	; 62
    2f40:	9a 83       	std	Y+2, r25	; 0x02
    2f42:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2f44:	e9 81       	ldd	r30, Y+1	; 0x01
    2f46:	fa 81       	ldd	r31, Y+2	; 0x02
    2f48:	87 89       	ldd	r24, Z+23	; 0x17
    2f4a:	90 8d       	ldd	r25, Z+24	; 0x18
    2f4c:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
		vPortFree( pxTCB );
    2f50:	89 81       	ldd	r24, Y+1	; 0x01
    2f52:	9a 81       	ldd	r25, Y+2	; 0x02
    2f54:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <vPortFree>
	}
    2f58:	0f 90       	pop	r0
    2f5a:	0f 90       	pop	r0
    2f5c:	cf 91       	pop	r28
    2f5e:	df 91       	pop	r29
    2f60:	08 95       	ret

00002f62 <memcpy>:
    2f62:	fb 01       	movw	r30, r22
    2f64:	dc 01       	movw	r26, r24
    2f66:	02 c0       	rjmp	.+4      	; 0x2f6c <memcpy+0xa>
    2f68:	01 90       	ld	r0, Z+
    2f6a:	0d 92       	st	X+, r0
    2f6c:	41 50       	subi	r20, 0x01	; 1
    2f6e:	50 40       	sbci	r21, 0x00	; 0
    2f70:	d8 f7       	brcc	.-10     	; 0x2f68 <memcpy+0x6>
    2f72:	08 95       	ret

00002f74 <memset>:
    2f74:	dc 01       	movw	r26, r24
    2f76:	01 c0       	rjmp	.+2      	; 0x2f7a <memset+0x6>
    2f78:	6d 93       	st	X+, r22
    2f7a:	41 50       	subi	r20, 0x01	; 1
    2f7c:	50 40       	sbci	r21, 0x00	; 0
    2f7e:	e0 f7       	brcc	.-8      	; 0x2f78 <memset+0x4>
    2f80:	08 95       	ret

00002f82 <strncpy>:
    2f82:	fb 01       	movw	r30, r22
    2f84:	dc 01       	movw	r26, r24
    2f86:	41 50       	subi	r20, 0x01	; 1
    2f88:	50 40       	sbci	r21, 0x00	; 0
    2f8a:	48 f0       	brcs	.+18     	; 0x2f9e <strncpy+0x1c>
    2f8c:	01 90       	ld	r0, Z+
    2f8e:	0d 92       	st	X+, r0
    2f90:	00 20       	and	r0, r0
    2f92:	c9 f7       	brne	.-14     	; 0x2f86 <strncpy+0x4>
    2f94:	01 c0       	rjmp	.+2      	; 0x2f98 <strncpy+0x16>
    2f96:	1d 92       	st	X+, r1
    2f98:	41 50       	subi	r20, 0x01	; 1
    2f9a:	50 40       	sbci	r21, 0x00	; 0
    2f9c:	e0 f7       	brcc	.-8      	; 0x2f96 <strncpy+0x14>
    2f9e:	08 95       	ret

00002fa0 <_exit>:
    2fa0:	f8 94       	cli

00002fa2 <__stop_program>:
    2fa2:	ff cf       	rjmp	.-2      	; 0x2fa2 <__stop_program>
